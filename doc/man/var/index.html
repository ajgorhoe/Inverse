<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;
      charset=windows-1252">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="GENERATOR" content="Mozilla/4.5 [en] (X11; I; HP-UX
      B.10.20 9000/780) [Netscape]">
    <title>Inverse manual: User Defined Variables in the Optimisation
      Shell INVERSE</title>
    <!-- Google Analitics - account Documents, 
	property Documents - all -->
    <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-96832295-1', 'auto');
	  ga('send', 'pageview');
	</script>
    <meta name="author" content="Igor Grešovnik">
    <meta name="description" content="Inverse manual: User Defined
      Variables in the Optimisation Shell INVERSE">
  </head>
  <body vlink="#551A8B" text="#000000" link="#0000EE" bgcolor="#FFFFFF"
    alink="#FE0000">
    <a href="../../../invhome.html"><img src="../../../invlogo.gif"
        nosave="" moz-do-not-send="true" title="Inverse Home"
        alt="Inverse logo" width="600" height="100" border="0"></a> <br>
    &nbsp; <br>
    &nbsp;
    <table nosave="" border="3" bgcolor="#99FFCC">
      <tbody>
        <tr nosave="">
          <td nosave=""><a name="list"></a><font size="-1"><a
                href="../index.html">MANUALS:</a></font>
            <blockquote>
              <li> <font size="-1"><a href="../short/index.html">Short
                    Guide to INVERSE</a></font></li>
              <li> <font size="-1"><a href="../flow/index.html">Flow
                    control</a></font></li>
              <li> <font size="-1"><a href="../calc/index.html">Expression

                    evaluator</a></font></li>
              <li> <b><font size="-1"><a href="index.html">User defined
                      variables</a></font></b></li>
            </blockquote>
            <blockquote>
              <blockquote>
                <li> <b><font size="-1"><a href="#_Toc436572397">Basic
                        Concepts of User-defined Variables</a></font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572402">Basic
                        Operations on User-defined Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572403">Special

                        Expression Evaluator's Functions varindex and
                        varcomponent</a></font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572406">Matrix
                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572427">Vector
                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572447">Scalar
                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572467">Counter

                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572467">Options</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572493">Field
                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572496">File
                        Variables</a>&nbsp;</font></b></li>
                <li> <b><font size="-1"><a href="#_Toc436572514">Shell's

                        Variables with a Pre-defined Meaning</a>&nbsp;</font></b></li>
              </blockquote>
              <li> <font size="-1"><a href="../int/index.html">General
                    file interface</a></font></li>
              <li> <font size="-1"><a href="../debug/index.html">Syntax
                    checker &amp; debugger</a></font></li>
              <li> <font size="-1"><a href="../sim/index.html">Interfaces

                    with simulation programmes</a></font></li>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
      <tbody>
        <tr nosave="" valign="TOP">
          <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
          <td nosave=""><b><font size="-1"><a
                  href="../manlist/index.html#list">Manuals list &amp;
                  contents</a></font></b></td>
          <td nosave=""><b><font size="-1"><a href="#contents">Table of
                  contents&nbsp;</a></font></b></td>
        </tr>
      </tbody>
    </table>
    <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp;
    <center>
      <p><b><i><font size="+2">User Defined Variables in the</font></i></b>
      </p>
      <p><b><i><font size="+2">Optimisation Shell INVERSE</font></i></b>
      </p>
      <p><b><font size="+1">Version 0</font></b> <br>
        &nbsp; <br>
        &nbsp; </p>
      <p><i>Igor Gresovnik</i> </p>
      <p><i><font size="-1">Ljubljana, the 24<sup> th</sup> of November
            1998</font></i></p>
    </center>
    <p><br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
    </p>
    <p><a name="contents"></a><b><font color="#FF0000"><font size="+1">Table
of

            Contents:</font></font></b> <br>
      &nbsp; <br>
      &nbsp; </p>
    <p><b><i>1. User-defined Variables </i></b><a href="#_Toc436572395">*</a>
    </p>
    <dir><b>1.1 How this Chapter is Organised </b><a
        href="#_Toc436572396">*</a> <br>
      &nbsp;
      <p><b><font size="+0">1.2 Basic Concepts of User-defined Variables
          </font></b><a href="#_Toc436572397">*</a> </p>
      <p><font size="-1">1.2.1 Tables of Elements </font><a
          href="#_Toc436572398">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.2.1.1 Addressing Variable Elements </font><a
          href="#_Toc436572399">*</a>
        <p><font size="-1">1.2.1.2 Addressing Variable Sub-tables and
            Variables </font><a href="#_Toc436572400">*</a> </p>
        <p><font size="-1">1.2.1.3 Operations on Variable Sub-tables </font><a
            href="#_Toc436572401">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.3 Basic Operations on User-defined Variables
        </font></b><a href="#_Toc436572402">*</a> <br>
      &nbsp;
      <p><b><font size="+0">1.4 Special Expression Evaluator's Functions
            varindex and varcomponent </font></b><a
          href="#_Toc436572403">*</a> </p>
      <p><font size="-1">1.4.1 varindex <i>[ indexnum ]</i> </font><a
          href="#_Toc436572404">*</a> </p>
      <p><font size="-1">1.4.2 varcomponent <i>[compnum ]</i> </font><a
          href="#_Toc436572405">*</a> <br>
        &nbsp; </p>
      <p><b><font size="+0">1.5 Matrix Variables </font></b><a
          href="#_Toc436572406">*</a> </p>
      <p><font size="-1">1.5.1 File Interpreter's Functions for
          Manipulation of Matrix Variables </font><a
          href="#_Toc436572407">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.5.1.1 newmatrix<i> { varname &lt; [ dim1,
            dim2, ... ] &gt; }</i> </font><a href="#_Toc436572408">*</a>
        <p><font size="-1">1.5.1.2 dimmatrix<i> { varname &lt; [ dim1,
              dim2, ... ] &gt; }</i> </font><a href="#_Toc436572409">*</a>
        </p>
        <p><font size="-1">1.5.1.3 setmatrix<i> { elspec matspec }</i> </font><a
            href="#_Toc436572410">*</a> </p>
        <p><font size="-1">1.5.1.4 copymatrixvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572411">*</a> </p>
        <p><font size="-1">1.5.1.5 movematrixvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572412">*</a> </p>
        <p><font size="-1">1.5.1.6 deletematrixvar<i> { varname }</i> </font><a
            href="#_Toc436572413">*</a> </p>
        <p><font size="-1">1.5.1.7 printmatrixvar<i> { varname }</i> </font><a
            href="#_Toc436572414">*</a> </p>
        <p><font size="-1">1.5.1.8 fprintmatrixvar<i> { varname }</i> </font><a
            href="#_Toc436572415">*</a> </p>
        <p><font size="-1">1.5.1.9 copymatrix<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572416">*</a> </p>
        <p><font size="-1">1.5.1.10 movematrix<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572417">*</a> </p>
        <p><font size="-1">1.5.1.11 deletematrix<i> { subspec }</i> </font><a
            href="#_Toc436572418">*</a> </p>
        <p><font size="-1">1.5.1.12 printmatrix<i> { subspec }</i> </font><a
            href="#_Toc436572419">*</a> </p>
        <p><font size="-1">1.5.1.13 printmatrix<i> { subspec }</i> </font><a
            href="#_Toc436572420">*</a> </p>
        <p><font size="-1">1.5.1.14 setmatrixcomponents<i> { subspec
              expr }</i>, shortly setmatcomp </font><a
            href="#_Toc436572421">*</a> </p>
        <p><font size="-1">1.5.1.15 matrixsum<i> { subspec1 subspec2
              subspecres }</i></font><a href="#_Toc436572422">*</a> </p>
        <p><font size="-1">1.5.1.16 matrixop<i> { spec = &lt; operator
              &gt; spec &lt; operator spec &gt; }</i>,<i> </i>matop </font><a
            href="#_Toc436572423">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.5.2 Expression Evaluator's Functions for
          Manipulating Matrix Variables </font><a href="#_Toc436572424">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.5.2.1 getmatrix<i> { varname &lt; elind1,
            elind2, ... &gt; rownum colnum }</i> </font><a
          href="#_Toc436572425">*</a>
        <p><font size="-1">1.5.2.2 getmartixdim<i> { varname dimnum }</i>
          </font><a href="#_Toc436572426">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.6 Vector Variables </font></b><a
        href="#_Toc436572427">*</a>
      <p><font size="-1">1.6.1 File Interpreter's Functions for
          Manipulating Vector Variables </font><a href="#_Toc436572428">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.6.1.1 newvector<i> { varname &lt; [ dim1,
            dim2, ... ] &gt; }</i> </font><a href="#_Toc436572429">*</a>
        <p><font size="-1">1.6.1.2 dimvector<i> { varname &lt; [ dim1,
              dim2, ... ] &gt; }</i> </font><a href="#_Toc436572430">*</a>
        </p>
        <p><font size="-1">1.6.1.3 setvector<i> { elspec vecspec }</i> </font><a
            href="#_Toc436572431">*</a> </p>
        <p><font size="-1">1.6.1.4 copyvectorvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572432">*</a> </p>
        <p><font size="-1">1.6.1.5 movevectorvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572433">*</a> </p>
        <p><font size="-1">1.6.1.6 deletevectorvar<i> { varname }</i> </font><a
            href="#_Toc436572434">*</a> </p>
        <p><font size="-1">1.6.1.7 printvectorvar<i> { varname }</i> </font><a
            href="#_Toc436572435">*</a> </p>
        <p><font size="-1">1.6.1.8 fprintvectorvar<i> { varname }</i> </font><a
            href="#_Toc436572436">*</a> </p>
        <p><font size="-1">1.6.1.9 copyvector<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572437">*</a> </p>
        <p><font size="-1">1.6.1.10 movevector<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572438">*</a> </p>
        <p><font size="-1">1.6.1.11 deletevector<i> { subspec }</i> </font><a
            href="#_Toc436572439">*</a> </p>
        <p><font size="-1">1.6.1.12 printvector<i> { subspec }</i> </font><a
            href="#_Toc436572440">*</a> </p>
        <p><font size="-1">1.6.1.13 fprintvector<i> { subspec }</i> </font><a
            href="#_Toc436572441">*</a> </p>
        <p><font size="-1">1.6.1.14 setvectorcomponents<i> { subspec
              expr }</i>, shortly setveccomp </font><a
            href="#_Toc436572442">*</a> </p>
        <p><font size="-1">1.6.1.15 vectorsum<i> { subspec1 subspec2
              subspecres }</i></font><a href="#_Toc436572443">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.6.2 Expression Evaluator's Functions for
          Manipulating Vector Variables </font><a href="#_Toc436572444">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.6.2.1 getvector<i> { varname &lt; elind1,
            elind2, ... &gt; compnum }</i> </font><a
          href="#_Toc436572445">*</a>
        <p><font size="-1">1.6.2.2 getvectordim<i> { varname dimnum }</i>
          </font><a href="#_Toc436572446">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.7 Scalar Variables </font></b><a
        href="#_Toc436572447">*</a>
      <p><font size="-1">1.7.1 File Interpreter's Functions for
          Manipulating Scalar Variables </font><a href="#_Toc436572448">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.7.1.1 newscalar<i> { varname &lt; [ dim1,
            dim2, ... ] &gt; }</i> </font><a href="#_Toc436572449">*</a>
        <p><font size="-1">1.7.1.2 dimscalar<i> { varname &lt; [ dim1,
              dim2, ... ] &gt; }</i> </font><a href="#_Toc436572450">*</a>
        </p>
        <p><font size="-1">1.7.1.3 setscalar<i> { elspec scalspec }</i>
          </font><a href="#_Toc436572451">*</a> </p>
        <p><font size="-1">1.7.1.4 copyscalarvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572452">*</a> </p>
        <p><font size="-1">1.7.1.5 movescalarvar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572453">*</a> </p>
        <p><font size="-1">1.7.1.6 deletescalarvar<i> { varname }</i> </font><a
            href="#_Toc436572454">*</a> </p>
        <p><font size="-1">1.7.1.7 printscalarvar<i> { varname }</i> </font><a
            href="#_Toc436572455">*</a> </p>
        <p><font size="-1">1.7.1.8 fprintscalarvar<i> { varname }</i> </font><a
            href="#_Toc436572456">*</a> </p>
        <p><font size="-1">1.7.1.9 copyscalar<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572457">*</a> </p>
        <p><font size="-1">1.7.1.10 movescalar<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572458">*</a> </p>
        <p><font size="-1">1.7.1.11 deletescalar<i> { subspec }</i> </font><a
            href="#_Toc436572459">*</a> </p>
        <p><font size="-1">1.7.1.12 printscalar<i> { subspec }</i> </font><a
            href="#_Toc436572460">*</a> </p>
        <p><font size="-1">1.7.1.13 printscalar<i> { subspec }</i> </font><a
            href="#_Toc436572461">*</a> </p>
        <p><font size="-1">1.7.1.14 setscalarcomponents<i> { subspec
              expr }</i>, shortly setscalcomp </font><a
            href="#_Toc436572462">*</a> </p>
        <p><font size="-1">1.7.1.15 scalarsum<i> { subspec1 subspec2
              subspecres }</i></font><a href="#_Toc436572463">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.7.2 Expression Evaluator's Functions for
          Manipulating Scalar Variables </font><a href="#_Toc436572464">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.7.2.1 getscalar<i> { varname &lt; elind1,
            elind2, ... &gt; }</i> </font><a href="#_Toc436572465">*</a>
        <p><font size="-1">1.7.2.2 getscalardim<i> { varname dimnum }</i>
          </font><a href="#_Toc436572466">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.8 Counter Variables </font></b><a
        href="#_Toc436572467">*</a>
      <p><font size="-1">1.8.1 File Interpreter's Functions for
          Manipulating Counter Variables </font><a
          href="#_Toc436572468">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.8.1.1 newcounter<i> { varname &lt; [ dim1,
            dim2, ... ] &gt; }</i> </font><a href="#_Toc436572469">*</a>
        <p><font size="-1">1.8.1.2 dimcounter<i> { varname &lt; [ dim1,
              dim2, ... ] &gt; }</i> </font><a href="#_Toc436572470">*</a>
        </p>
        <p><font size="-1">1.8.1.3 setcounter<i> { elspec countspec }</i>
          </font><a href="#_Toc436572471">*</a> </p>
        <p><font size="-1">1.8.1.4 copycountervar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572472">*</a> </p>
        <p><font size="-1">1.8.1.5 movecountervar<i> { varname1 varname2
              }</i> </font><a href="#_Toc436572473">*</a> </p>
        <p><font size="-1">1.8.1.6 deletecountervar<i> { varname }</i> </font><a
            href="#_Toc436572474">*</a> </p>
        <p><font size="-1">1.8.1.7 printcountervar<i> { varname }</i> </font><a
            href="#_Toc436572475">*</a> </p>
        <p><font size="-1">1.8.1.8 fprintcountervar<i> { varname }</i> </font><a
            href="#_Toc436572476">*</a> </p>
        <p><font size="-1">1.8.1.9 copycounter<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572477">*</a> </p>
        <p><font size="-1">1.8.1.10 movecounter<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572478">*</a> </p>
        <p><font size="-1">1.8.1.11 deletecounter<i> { subspec }</i> </font><a
            href="#_Toc436572479">*</a> </p>
        <p><font size="-1">1.8.1.12 printcounter<i> { subspec }</i> </font><a
            href="#_Toc436572480">*</a> </p>
        <p><font size="-1">1.8.1.13 fprintcounter<i> { subspec }</i> </font><a
            href="#_Toc436572481">*</a> </p>
        <p><font size="-1">1.8.1.14 setcountercomponents<i> { subspec
              expr }</i>, shortly setcountcomp </font><a
            href="#_Toc436572482">*</a> </p>
        <p><font size="-1">1.8.1.15 countersum<i> { subspec1 subspec2
              subspecres }</i> </font><a href="#_Toc436572483">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.8.2 Expression Evaluator's Functions for
          Manipulating Counter Variables </font><a
          href="#_Toc436572484">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.8.2.1 getcounter<i> { varname &lt; elind1,
            elind2, ... &gt; }</i> </font><a href="#_Toc436572485">*</a>
        <p><font size="-1">1.8.2.2 getcounterdim<i> { varname dimnum }</i>
          </font><a href="#_Toc436572486">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.9 Options </font></b><a
        href="#_Toc436572467">*</a>
      <p><font size="-1">1.9.1 File Interpreter's Functions for Handling
          Options </font><a href="#_Toc436572488">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.9.1.1 setoption<i> { optspec }</i> </font><a
          href="#_Toc436572489">*</a>
        <p><font size="-1">1.9.1.2 clearoption<i> { optspec }</i> </font><a
            href="#_Toc436572490">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.9.2 Expression Evaluator's Functions for
          Handling Options </font><a href="#_Toc436572491">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.9.2.1 getoption<i> { varname &lt; elind1,
            elind2, ... &gt; }</i> </font><a href="#_Toc436572492">*</a></dir>
      <br>
      &nbsp;
      <p><b><font size="+0">1.10 Field Variables </font></b><a
          href="#_Toc436572493">*</a> </p>
      <dir>&nbsp;</dir>
      <p><br>
        <b><font size="+0">1.11 File Variables </font></b><a
          href="#_Toc436572496">*</a> </p>
      <p><font size="-1">1.11.1 File Interpreter's Functions for
          Manipulating File Variables </font><a href="#_Toc436572497">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.11.1.1 newfile<i> { varname &lt; [ dim1, dim2,
            ... ] &gt; }</i> </font><a href="#_Toc436572498">*</a>
        <p><font size="-1">1.11.1.2 dimfile<i> { varname &lt; [ dim1,
              dim2, ... ] &gt; }</i> </font><a href="#_Toc436572499">*</a>
        </p>
        <p><font size="-1">1.11.1.3 setfile<i> { elspec filespec }</i> </font><a
            href="#_Toc436572500">*</a> </p>
        <p><font size="-1">1.11.1.4 copyfilevar<i> { varname1 varname2 }</i>
          </font><a href="#_Toc436572501">*</a> </p>
        <p><font size="-1">1.11.1.5 movefilevar<i> { varname1 varname2 }</i>
          </font><a href="#_Toc436572502">*</a> </p>
        <p><font size="-1">1.11.1.6 deletefilevar<i> { varname }</i> </font><a
            href="#_Toc436572503">*</a> </p>
        <p><font size="-1">1.11.1.7 printfilevar<i> { varname }</i> </font><a
            href="#_Toc436572504">*</a> </p>
        <p><font size="-1">1.11.1.8 fprintfilevar<i> { varname }</i> </font><a
            href="#_Toc436572505">*</a> </p>
        <p><font size="-1">1.11.1.9 copyfile<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572506">*</a> </p>
        <p><font size="-1">1.11.1.10 movefile<i> { subspec1 subspec2 }</i>
          </font><a href="#_Toc436572507">*</a> </p>
        <p><font size="-1">1.11.1.11 deletefile<i> { subspec }</i> </font><a
            href="#_Toc436572508">*</a> </p>
        <p><font size="-1">1.11.1.12 printfile<i> { subspec }</i> </font><a
            href="#_Toc436572509">*</a> </p>
        <p><font size="-1">1.11.1.13 fprintfile<i> { subspec }</i> </font><a
            href="#_Toc436572510">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.11.2 Expression Evaluator's Functions for
          Manipulating File Variables </font><a href="#_Toc436572511">*</a>
      </p>
      <dir>&nbsp; <br>
        <font size="-1">1.11.2.1 getfile<i> { varname dataid &lt;
            elind1, elind2, ... &gt; }</i> </font><a
          href="#_Toc436572512">*</a>
        <p><font size="-1">1.11.2.2 getfiledim<i> { varname dimnum }</i>
          </font><a href="#_Toc436572513">*</a> <br>
          &nbsp; <br>
          &nbsp;</p>
      </dir>
      <b><font size="+0">1.12 Shell's Variables with a Pre-defined
          Meaning </font></b><a href="#_Toc436572514">*</a>
      <p><font size="-1">1.12.1 Pre-defined Matrix, Vector and Scalar
          Variables </font><a href="#_Toc436572515">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.12.1.1 Scalar Pre-defined Variables </font><a
          href="#_Toc436572516">*</a>
        <p><font size="-1">1.12.1.2 Vector Pre-defined Variables </font><a
            href="#_Toc436572517">*</a> </p>
        <p><font size="-1">1.12.1.3 Matrix Pre-defined Variables </font><a
            href="#_Toc436572518">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.12.2 File Interpreter's Functions for Setting
          Shell's Internal Data Related to Pre-defined Variables </font><a
          href="#_Toc436572519">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.12.2.1 setnumparam<i> { val }</i> </font><a
          href="#_Toc436572520">*</a>
        <p><font size="-1">1.12.2.2 setnumobjectives<i> { val }</i> </font><a
            href="#_Toc436572521">*</a> </p>
        <p><font size="-1">1.12.2.3 setnumconstraints<i> { val }</i> </font><a
            href="#_Toc436572522">*</a> </p>
        <p><font size="-1">1.12.2.4 setnummeas<i> { val }</i> </font><a
            href="#_Toc436572523">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.12.3 Expression Evaluator's Functions for
          Accessing Shell's Internal Data Related to Pre-defined
          Variables </font><a href="#_Toc436572524">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.12.3.1 getnumparam<i> [ ]</i> </font><a
          href="#_Toc436572525">*</a>
        <p><font size="-1">1.12.3.2 getnumobjectives<i> [ ]</i> </font><a
            href="#_Toc436572526">*</a> </p>
        <p><font size="-1">1.12.3.3 getnumconstraints<i> [ ]</i> </font><a
            href="#_Toc436572527">*</a> </p>
        <p><font size="-1">1.12.3.4 getnummeas<i> [ ]</i> </font><a
            href="#_Toc436572528">*</a></p>
      </dir>
      <p><br>
        <font size="-1">1.12.4 Pre-defined File Variables </font><a
          href="#_Toc436572529">*</a> </p>
      <dir>&nbsp; <br>
        <font size="-1">1.12.4.1 File Pre-defined Variables </font><a
          href="#_Toc436572530">*</a></dir>
    </dir>
    <br>
    &nbsp; <br>
    &nbsp;
    <ol>
      <li> <a name="_Toc436572395"></a><b><font size="+2">User-defined
            Variables</font></b></li>
      <br>
      &nbsp;
      <p>&nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; </p>
      <p>User-defined variables are used to store different types of
        data in the shell. Results of various operations and algorithms
        can be stored in these variables for further use in the solutio
        procedure. </p>
      <p>Another important use of user-defined variables is for
        transferring data between different modules, operations and
        algorithms of the shell. A typical example of that is passing
        data between optimisation algorithms and the function which
        performs direct analyses. Variables with a pre-defined meaning
        are used for this task. </p>
      <p>Variable types that are currently implemented in the shell are
        scalar, vector, matrix, file and field. <br>
        &nbsp; <br>
        &nbsp; </p>
      <ol>
        <li> <a name="_Toc436572396"></a><b><font size="+1">How this
              Chapter is Organised</font></b></li>
        <br>
        &nbsp;
        <p>&nbsp; <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; </p>
        <p>In the first sub-chapter some basic concepts of user-defined
          variables and functions for variable manipulation are
          explained. Understanding these concepts can help the user to
          understand the behaviour of the supporting interpreter's and
          calculator's functions. However, it is not absolutely
          necessary to read through this chapter to komprehend the next
          ones. Therefore if you find the chapter boring and dry, simply
          skip it. You can return back later when you will have some
          insight about what everything is about, or when you feel the
          need for clearing some conceptual things. </p>
        <p>The first part of the first sub-chapter explains what
          user-defined variables of the shell actually are. The second
          part offers somhow more practical information about how to
          address parts of the data stored in user-defined variables in
          the argument blocks of the user-defined functios. The third
          part explains the concepts of operations which affect groups
          of data objects of a given type. Storing groups of objects in
          a single variable and performing operations on them is a
          strong feature of the shell. An experienced user can easily
          take the advantage of this feature. </p>
        <p>In the second sub-chapter a rough overview over the basic
          functions for variable manipulation is made. The examples
          refer to matrix variables, but similar functions exist for
          most of the variable types. The user is advised to read this
          sub-chapter to get a compact view on the subject. </p>
        <p>The third sub-chapter describes the functions which enable an
          advanced way of setting components of the variables. The
          chapter is in that place because the described functions are
          used for several variable types. The user is advised to skip
          the chapter and return to it when needed. </p>
        <p>The following sub-chapters include description of functions
          for handling of different types of variables. The first of
          these sub-chapters is dedicated to matrix variables. Many
          things described here are similar for other variable types.
          Especialy the treatment of vector, scalar and field variables
          is in many terms the same. The user can therefore take this as
          an representative example which can ease the introduction to
          the treatment of other variable types. In many cases it will
          happen, for expmple, that the user will not need to read a
          description of a specific function for vector manipulation if
          he is already familiar with the appropriate function for
          matrix manipulation. </p>
        <p>The last sub-chapter is dedicated to variables with a
          pre-defined meaning. These variables provide the necessary
          data links between different modules nad operations of the
          shell. They are of great importance for setting optimisation
          and inverse problems. </p>
        <p>Finally, let me conclude with a <b><i>useful hint</i></b>.
          Maybe it is not bed at all to start at the chapter about
          matrix variables. At least you will quickly get a feeling
          about which information you miss to get a clear insight. Have
          a nice reading! <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; </p>
        <li> <a name="_Toc436572397"></a><b><i><font size="+2">Basic
                Concepts of User-defined Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Each type of the shell's user-defined variables has its own
          set of file interpreter's and expression evaluator's functions
          for manipulating variables of that type. Basic manipulation
          includes creating, copying, renaming and deleting variables.
          Beside that, for each type of variables there exists a
          specific set of operations typical for that type, i.e.
          algebraic operations and setting or obtaining components for
          vector and matrix variables. <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572398"></a><b><font size="+1">Tables of
                Elements</font></b></li>
          <br>
          &nbsp;
          <p>&nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; </p>
          <p>Each user-defined variable can hold a multi-dimensional
            table of elements of a specific data type. Number of
            dimensions of this table is called <b><i>rank</i></b> of a
            variable. Variable's element tables can be thought of as a
            recursive tables, where the basic level holds a specific
            number of sub-tables, each of which again holds a number of
            sub-tables, etc., untill the last level which holds a table
            of elements of a specific type. Numbers of sub-tables or
            element which level holds are called <i><u>variable
                dimensions</u></i>, and the umber of levels (or
            dimensions) of a variable is called <b><i>variable rank</i></b>.
            Variables with rank 0 can hold only one element. Variables
            with rank greater than 0 can hold as many data elements as
            is the product of variable dimensions. </p>
          <p><b>Example:</b> </p>
          <p>Suppose we have a vector variable <i>v</i> with rank 3 and
            dimensions 2, 3 and 2. The variable can hold 3*2*2=12
            elements which are organised in the following way: </p>
          <p><b><font size="-1">Table v:</font> contains 3 sub-tables
              (because the first dimension is )</b> </p>
          <p><b>Sub-table v[1]: contains 2 sub-tables (because the
              second dimension is 2)</b> </p>
          <p><b>Sub-table v[1,1]: contains 2 elements (because the third
              dimension is 2)</b> </p>
          <p><b>Element <i>v[1,1,1]</i></b> </p>
          <p><font size="-1"><b>Element </b><i>v[1,1,2]</i></font> </p>
          <p><font size="-1"><b>Sub-table v[1,2]:</b> contains 2
              elements (because the third dimension is 2)</font> </p>
          <p><font size="-1"><b>Element </b><i>v[1,2,1]</i></font> </p>
          <p><font size="-1"><b>Element </b><i>v[1,2,2]</i></font> </p>
          <p><font size="-1"><b>Sub-table v[2]:</b> contains 2
              sub-tables (because the second dimension is 2)</font> </p>
          <p><font size="-1"><b>Sub-table v[2,1]:</b> contains 2
              elements (because the third dimension is 2)</font> </p>
          <p><font size="-1"><b>Element </b><i>v[2,1,1]</i></font> </p>
          <p><font size="-1"><b>Element </b><i>v[2,1,2]</i></font> </p>
          <p><font size="-1"><b>Sub-table v[2,2]:</b> contains 2
              elements (because the third dimension is 2)</font> </p>
          <p><font size="-1"><b>Element </b><i>v[2,2,1]</i></font> </p>
          <p><font size="-1"><b>Element </b><i>v[2,2,2]</i></font> </p>
          <p><font size="-1"><b>Sub-table v[3]:</b> contains 2
              sub-tables (because the second dimension is 2)</font> </p>
          <p><font size="-1"><b>Sub-table v[3,1]:</b> contains 2
              elements (because the third dimension is 2)</font> </p>
          <p><font size="-1"><b>Element </b><i>v[3,1,1]</i></font> </p>
          <p><font size="-1"><b>Element </b><i>v[3,1,2]</i></font> </p>
          <p><font size="-1"><b>Sub-table v[3,2]:</b> contains 2
              elements (because the third dimension is 2)</font> </p>
          <p><font size="-1"><b>Element </b><i>v[3,2,1]</i></font> </p>
          <p><font size="-1"><b>Element </b><i>v[3,2,2]</i></font> </p>
          <p>The variable <i>v</i> containd three sub-tables, each of
            which contains two sub-sub tables, each of which contains
            two vectors. Variable lazout is also shwn in Table 1. <br>
            &nbsp; </p>
          <p><a name="_Ref433876192"></a><b>Table 1</b>: Variable <i>v</i>
            with dimensions 3*2*2.
            <table width="538" cellpadding="7" border="">
              <tbody>
                <tr>
                  <td width="16%" valign="TOP">Level 1:</td>
                  <td width="14%" valign="TOP"><i><font size="-1">variable

                        <b>v</b></font></i></td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                </tr>
                <tr>
                  <td width="16%" valign="TOP">Level 2:</td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[1]</font></i></b></td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[2]</font></i></b></td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[3]</font></i></b></td>
                  <td width="14%" valign="TOP">&nbsp;</td>
                </tr>
                <tr>
                  <td width="16%" valign="TOP">Level 3:</td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[1,1]</font></i></b></td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[1,2]</font></i></b></td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[2,1]</font></i></b></td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[2,2]</font></i></b></td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[3,1]</font></i></b></td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[3,2]</font></i></b></td>
                </tr>
                <tr>
                  <td width="16%" valign="TOP">Elements:</td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[1,1,1]</font></i></b>
                    <p><b><i><font size="-1">v[1,1,2]</font></i></b></p>
                  </td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[1,2,1]</font></i></b>
                    <p><b><i><font size="-1">v[1,2,2]</font></i></b></p>
                  </td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[2,1,1]</font></i></b>
                    <p><b><i><font size="-1">v[2,1,2]</font></i></b></p>
                  </td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[2,2,1]</font></i></b>
                    <p><b><i><font size="-1">v[2,2,2]</font></i></b></p>
                  </td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[3,1,1]</font></i></b>
                    <p><b><i><font size="-1">v[3,1,1,2]</font></i></b></p>
                  </td>
                  <td width="14%" valign="TOP"><b><i><font size="-1">v[3,2,1]</font></i></b>
                    <p><b><i><font size="-1">v[3,2,2]</font></i></b></p>
                  </td>
                </tr>
              </tbody>
            </table>
          </p>
          <p>In the case of variables that hold elements which themselve
            contain tables of elements, e.g. vectors and matrices, the
            same variable can contain elements of different dimensions.
            Exept at variables with a pre-defined meaning, it is
            completely upon user's will which are the dimensions of
            elements stored in a specific variable. However, this
            freedom is seldomly used because it decreases the level of
            organisation. </p>
          <p>In the case of multi-dimensional tables, <u>each sub-table
              of the same level holds the same number of sub-tables or
              elements, which equals the dimension of that level</u>. Of
            course, some elements can contain no data. </p>
          <p>In the above example, the first level (i.e. the variable
            itself) contains three sub-tables of the second level
            (because the first dimension is 3), i.e. <i>v[1], v[2] </i>and
            <i>v[3]</i>. Each of these contains two sub-tables of the
            third level (because the second dimension is 2), i.e. <i>v[1]</i>
            contains <i>v[1,1]</i> and<i> v[1,2]</i>, <i>v[2]</i>
            contains<i> v[2,1]</i> and<i> v[2,2]</i> and <i>v[3]</i>
            contains<i> v[3,1]</i> and <i>v[3,2]</i>. And each of these
            sub-tables of the third level contains two elements because
            the third dimension is 2. <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; </p>
          <ol>
            <li> <a name="_Toc436572399"></a><b><font size="+1">Addressing

                  Variable Elements</font></b></li>
            <br>
            &nbsp;
            <p>&nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <p>Special conventions exist about referencing shell's
              user-defined variables and their elements in the argument
              blocks of the file interpreter's functions. </p>
            <p>First of all, each variable has its name. Variables of
              different types can have the same names, e.g. we can have
              both matrix and vector variable names <i>a1</i>. Usual
              rules apply for variable names. They are strings which
              consist of letters and numbers, while the first character
              of a name must always be a letter. </p>
            <p>Since variables can hold multi-dimensional tables of
              elements, we must specify which element of the variable's
              element table is in question. This is done by indices
              which specify the position of an element in the element
              table. Indices must be listed in square brackets and be
              separated by spaces or commas. They specify, by turns,
              from which sub-table of a specific level the element must
              be taken. Variable name followed by a list of indices in
              square brackets form the <b><i>specification of an
                  element</i></b>. Spaces are allowed between the
              variable name and index list. </p>
            <p><b>Example:</b> </p>
            <p>Let us have a vector variable <i>v</i> of rank 3 and
              dimensions 3*2*2. The specification <i>v[3,1,2]</i>
              refers to the second vector of the first sub-sub-table of
              the third sub-table of the variable <i>v</i>. </p>
            <p>Variables of rank 0 can hold only one element, therefore
              there is no need to specify indices when addressing their
              only element. Element specification can in this case be
              only a variable name, or eventually we can put empty
              square brackets behind the name (e.g. <i>v1</i>, <i>v1[
                ]</i>). <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572400"></a><b><font size="+1">Addressing

                  Variable Sub-tables and Variables</font></b></li>
            <br>
            &nbsp;
            <p>&nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <p>Some functions perform operations on whole sub-tables of
              elements rather than on individual elements of variables.
              Specification of variables' element sub-tables is similar
              to specification of individual arguments. The only
              difference is that few last indices are not specified,
              i.e. less indices are usually listed than the variable
              rank. It is always considered than the last indices are
              missing. A sub-table spcified this way consists of
              elements which have fixed first indices as specified in
              the specification, while the rest indices vary in their
              range (from 1 to the appropriate dimension). As usual, the
              precedent indices change faster while elements are listed
              by order. </p>
            <p><b>Example:</b> </p>
            <p>Suppose we have a variable <i>v</i> of rank 3 and
              dimensions 3*2*2. The specification <i>v[2]</i> then
              refers to a sub-table of rank 2 and dimensions 2*2 with
              elements <i>v[2,1,1], v[2,1,2], v[2,2,1]</i> and <i>v[2,2,2]</i>.
              The specification <i>v[2,1]</i>refers to the first
              sub-table of this table, which contains elements <i>v[2,1,1]</i>
              and <i>v[2,1,2]</i>. </p>
            <p>A sub-table specification can also refer to a whole
              element table of a variable. In this case the
              specification consists only of a variable name, which can
              be eventionally followed by empty square brackets, i.e. <i>v</i>
              or <i>v[ ]</i>. </p>
            <p>Some operations perform not on data elements or element
              sub-tables, but on whole variables. The appropriate
              functions require <b><i><u>variable specifications</u></i></b>
              in their argument blocks. These consist only of variable
              names and <u>may not be followed by square brackets, not
                even empty ones</u>. <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572401"></a><b><font size="+1">Operations

                  on Variable Sub-tables</font></b></li>
            <br>
            &nbsp;
            <p>&nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <p>Some general rules apply to operations on the element
              sub-tables of variables. These rules are mostly concerned
              with the dimension compatibility. The file interpreter's
              functions which operate on variable sub-tables can be
              deivided inoto several sub-groups. <br>
              &nbsp; <br>
              &nbsp; </p>
            <ol>
              <li> <b>Functions that just Perform Operations on
                  Elements (Simple Unary operations)</b></li>
              <br>
              &nbsp;
              <p>&nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; </p>
              <p>These functions iterate over indices of the element
                sub-tables, take the appropriate elements one by one and
                perform an operation on them. Sometimes it is important
                to know which is the order in which elements are taken,
                because the operations which are performed on the
                elements can depent on the state of other elements of
                the sub-table. </p>
              <p>The operation begins with the element that has all
                indices of the sub-table set to 1. indices are then
                incremented in trns, starting with the last one. When a
                certain index reaches its range (i.e. the appropriate
                dimension of the sub-table), it is set to 1 and its
                preceeding index is incremented. This is repeated untill
                all indices reach their range. </p>
              <p><b>Example:</b> </p>
              <p>Suppose that we have a variable <i>v</i> of dimensions
                3*2*2, and we perform an unary operation named <i>unopsimp</i>
                on the elements of its sub-table <i>v[2]</i>. The code
                which does that is </p>
              <p><b><i>unopsimp</i> { v[2] }</b> </p>
              <p>and the operation is performed on the elements in the
                following order: </p>
              <p><i>v[2,1,1], v[2,1,2], v[2,2,1], v[2,2,2]</i>. </p>
              <p>The first index is fixet since it was given in the
                specification, while the rest two indices change
                alternatelz in the above described way. <br>
                &nbsp; <br>
                &nbsp; </p>
              <li> <b>Functions that Perform Operations on Elements and
                  Store Results in Another Sub-table (Unary Operations
                  Which Store Results)</b></li>
              <br>
              &nbsp;
              <p>&nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; <br>
                &nbsp; </p>
              <p>These operations usually leave the elements on which
                they act unchanged, but store the results of the
                performed operations in the elements of another table
                (there can be exceptions). </p>
              <p>The order in which operations are performed is the same
                as in the previous case. The difference is that another
                element sub-table must be specified in which the results
                of operations are stored. <u>The result table must be
                  of the same dimensions than the one on which the
                  operations are performed</u>. The results of
                operations on elements of the first sub-table are then
                stored in the appropriate elements of the result
                sub-table, i.e. in the elements with the same indices. </p>
              <p>Usually, the elementsd of the result sub-table don't
                need to be initialised. While the results are stored in
                the table, the elements are appropriately initialised if
                necessary. </p>
              <p>Instead of properly specifying the result dable of the
                appropriate dimensions, we can only specify the variable
                name. If a variable with that name does not yet exist,
                it is created before the beginning of the operation. It
                is created with the element table of the same dimensions
                than the dimensions of the element sub-table on which
                the operation is performed. If a whole variable table is
                specified (not a sub-table) which exists, but does not
                have the right dimensions, it is deleted and created
                anew with the right dimensions. If a result sub-table is
                specified with wrong dimensions, this is an error and
                the operation will not be performed. </p>
              <p>Specifications of variables or sub-tables on which the
                operation is performed and in which the results are
                stored are arguments of the file interpreter's function
                that performs the operation. Usually, the specification
                of the sub-table on which the operation is performed, is
                the first argument, and the specification of the
                sub-table in which the results are stored, is the second
                argument of such functions. </p>
              <p><b>Example:</b> </p>
              <p>Let's have a variable <i>v</i> of dimensions 3*2*2, a
                variable <i>r1</i> with dimensions 4*2*2, a variable <i>r2</i>
                with dimensions 3*2. Let's say we want to perform the
                operation <i>unop</i> on the sub-table <i>v[3]</i> and
                that we would like to use one of the variables <i>r1</i>
                or <i>r2</i> for storing results of the operation. We
                can to that different ways: </p>
              <p><b><i>unop</i> { r1[2] v[3] }</b> </p>
              <p>is legal since the dimensions of the sub-tables <i>r2[2]</i>and

                <i>v[3]</i> match. The operation is performed in turns
                on elements <i>v[3,1,1], v[3,1,2], v[3,2,1]</i> and <i>v[3,2,2]</i>
                and the results of the operation are stored in elements
                <i>r1[3,1,1], r1[3,1,2], r1[3,2,1]</i> and <i>r1[3,2,2]</i>,
                accordingly. </p>
              <p><b><i>unop</i> { r2 v[3] }</b> </p>
              <p>is also legal because the first specification specifies
                the whole variable table. Since the dimensions do not
                match, variable <i>r2</i> is first deleted and then
                created anew with dimensions 2*2 that match the
                dimensions os <i>v[3]</i>. The situation is similar if
                we perform </p>
              <p><b><i>unop</i> { r1 v[3] }</b> </p>
              <p>We can not, however, perform the operation </p>
              <p><b><i>unop</i> { r1[1] v[3] }</b> </p>
              <p>since <i>r1[1]</i> is a sub-table of the variable <i>r1</i>
                and it does not have the same dimensions than <i>v[3]</i>.
                <br>
                &nbsp; <br>
                &nbsp; </p>
              <li> <b>Operations on Pairs of Variable Elements (Binary
                  Operations)</b></li>
            </ol>
          </ol>
        </ol>
        <ol>
          <ol>
            <ol>
              Most of binary operations on pairs of elements of variable
              sub-tables store their results in a third table of
              elements. For this result table the same results apply as
              in the chapter about unary operations which store their
              results.
              <p>There are two possibilities for the element tables on
                which the operation is performed. They can either be of
                the same dimensions or one table has a single element.
                In the second case, the operation combines the single
                element with all elements of the other sub-table. </p>
              <p>At functions which perform binary operations, the
                specification of the result sub-table (or variable), and
                specifications of the sub-tables on which the operation
                is performed, are arguments of these functions. Usualy
                the specificatios of the sub-tables on which the
                operation is performed, are the first two arguments, and
                the specification of the result sub-table is the third
                argument of such functions. If the appropriate
                operations are not commutative, the order of the first
                two arguments matters, too. </p>
              <p><b>Example:</b> </p>
              <p>Let us say there are variables <i>v1</i> of dimensions
                3*2*2, <i>v2</i> of dimensions 5*2*2, <i>v3</i> of
                dimensions 4*2, <i>r1</i> of dimensions 2*2*2, and <i>r2</i>
                of dimension 2*3, and a binary operation named <i>binop</i>.
                Then we can perform the following operations: </p>
              <p><b><i>binop</i> { r1[2] v1[2] v2[4] }</b> </p>
              <p>is valid since all sub-tables have the same dimensions.
              </p>
              <p><b><i>binop</i> { r1[ ] v1[2] v2[4] }</b> </p>
              <p>is also valid since the first argument specifies the
                whole element table of the variable <i>r1</i>. This
                table is not of the same dimension as should the result
                table be, therefore variable <i>r1</i> is first deleted
                and then created with write dimensions (2*2) before the
                operation is performed. </p>
              <p><b><i>binop</i> { r2[ ] v3[2,1,2] v2[5] }</b> </p>
              <p>is also legal because <i>v3[2,1]</i> specifies a
                single element. This element is in turns combined with
                all four elements of the sub-table <i>v2[5]</i>, the
                operation is performed on such pairs and results are
                stored in the appropriate elements of variable <i>r2</i>.
                This variable is deleted and then created anew with
                dimensions 2*2 before the operation begins. </p>
              <p><b><i>binop</i> { r1[ ] v3 v2[1] }</b> </p>
              <p>is not legal since the dimensions of sub-tables <i>v3</i>
                and <i>v2[1]</i> do not match.</p>
            </ol>
          </ol>
        </ol>
        <br>
        &nbsp; <br>
        &nbsp;
        <li> <a name="_Toc436572402"></a><b><i><font size="+2">Basic
                Operations on User-defined Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>For every tiype of the user-defined shell's variables there
          is a set of interreter's and calculator's functions for
          manipulation of these variables. Some of these functions are
          of a general character and are similar for almost all types of
          variables. </p>
        <p>Among the most important are the file interpreter's functions
          for creating variables and setting their values. For matrix
          variables these are functions <b>newmatrix</b>, <b>dimmatrix</b>
          and <b>setmatrix</b>. </p>
        <p>The <b>newmatrix</b> function creates a matrix variable with
          specific dimensions. The only argument of this function is the
          name of the matrix variable followed by the list of dimensions
          in a square bracke. If this bracket is empty or if it is
          omitted, a variable with rank 0 is created (such variable can
          hold a single element). If a matrix variable with a given name
          exists when the <b>newmatrix</b> function is called, it is
          first deleted and then created. </p>
        <p>The <b>dimmatrix</b> function is similar than <b>newmatrix</b>,
          except that if a matrix variables of a given name already
          exists and has right dimensions, it is leaved untouched. </p>
        <p>The <b>setmatrix</b> function initialises individual
          elements of a matrix variable according to the value given in
          its argument block. The first argument is the specification of
          a matrix element, i.e. a variable name followed by a list of
          indices). The second argument specifies the values that should
          be assigned to that matrix element. This includes matrix
          dimension and all components, although only the dimension or
          individual components can be given. </p>
        <p>If the first argument of the <b>setmatrix</b> function is a
          complete element specification with a list of indices, a given
          element must already exist. This can be assured by an
          appropriate execution of the <b>newmatrix</b> or <b>dimmatrix</b>
          function. If the element specification is given without an
          index list and a matrix variable with a given name does not
          exist yet, it is first created with rank 0. This is the only
          case when the <b>setmatrix</b> command creates a matrix
          variable. In other cases the variable must exist before. </p>
        <p>Similar functions than <b>newmatrix</b> and <b>dimmatrix</b>
          exist for other types of variables. They only have different
          name (string "matrix" is replaced by the appropriate type
          name). Similar functions to <b>setmatrix</b> exist for other
          types of variables, with appropriately different names and
          formats of the second argument which specifies the element
          values. </p>
        <p>Other important general functions are these for copying,
          moving and printing variables or their elements. For matrix
          variables, the function <b>movematrixvar</b> renames a matrix
          variable. The first name is the old and the second argument is
          a new name of the variable. Function <b>copymatrixvar</b>
          copies a whole matrix variable to another matrix variable.
          Again, names of the copied and the result variables are the
          two arguments of the functions. The <b>movematrixvar</b>
          function first deletes the second variable if it already
          exists, while the <b>copymatrixvar</b> function deletes it
          only if it is not of the right dimensions, and the same
          applies for individual elements. </p>
        <p>The <b>copymatrix</b> function copies sub-tables of elements
          of matrix variables to another element sub-tables. It behaves
          like functions which perform unary operations on element
          sub-tables and store results to another sub-tables. Similarly
          the <b>movematrix</b> function moves sub-tables of elements
          to another sub-tables. It also behaves like functions which
          perform unary operations on element sub-tables and store
          results to another sub-tables. Particularity of this function
          is that the elements on which operation is performed are also
          affected (they are deleted). </p>
        <p>The <b>printmatrix</b> prents a sub-table of elements of a
          matrix variable. It behaves like a simple unary operation. The
          <b>printmatrixvar</b> function does the same, except that it
          prints all matrices of the variable's element table and also
          some additional data about the variable. </p>
        <p>For each variable type there are usually one or more
          expression evaluator's functions which return specific
          information about the variable's elements. For matrix
          variables such functions are <b>getmatrix</b>, which returns
          matrix element's components or dimensions, and <b>getmatrixdim</b>,
          which returns dimensions or rank of a matrix variable. </p>
        <p>For variables that contain numerical information (i.e.
          scalars, vectors or matrices), there are functions which set
          the components of these information for sub-tables of
          variables' elements. For matrix variables such function is <b>setmatrixcomponents</b>
          or shortly <b>setmatcomp</b>. The first argument of this
          function is a specification of a sub-group of elements on
          which the operation is performed. The second argument is a
          mathematical expression the value of which is evauated and
          assigned to each component of the group of matrices
          separately. Two special calculator's functions, namely <b>varindex</b>
          and <b>varcomponent</b> can be used in functions similar to <b>setmatcomp</b>.
          The first one returns a specific index of the matrix element,
          and the second one returns the specific component number of
          the matrix component which is currently being assigned. <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; </p>
        <li> <a name="_Toc436572403"></a><b><i><font size="+2">Special
                Expression Evaluator's Functions </font>varindex and
              varcomponent</i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Calculator's functions <b>varindex</b> and <b>varcomponent</b>
          are designed to support those file interpreter's functions
          which iterate over components of the variable's element
          sub-tables and assigne them values specified by mathemathical
          expressions. Such functions are, for example, <b>setmatomp</b>,
          <b>setveccomp</b>, <b>setscalcomp</b>, etc. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572404"></a><b><font size="+1">varindex
              </font><i>[ indexnum ]</i></b></li>
          <br>
          Returns a specific index (defined by <i>indexnum</i>) of the
          variable's element which is currently in the assigment
          procedure of a function like <b>setmatcomp</b>. The function
          can be called only in the specific situation where a component
          of a variable's element is being assigned by a function like <b>setmatcomp</b>.
          <p>If the value of <i>indexnum</i> is zero, the function
            returns the rank (i.e. number of dimensions) of the element
            table of the variable in the assignment procedure. </p>
          <p><b>Example:</b> </p>
          <p>Let us have a matrix variable <i>m</i> of dimensions 2*3
            and let us execute the command </p>
          <p><b><font size="+0">setmatcomp</font><i> { m[2] varindex[0]
                + 3 * varindex[2] }</i></b> </p>
          <p>When the components of the matrix sub-table are assigned,
            the term <i>varindex[0]</i> has the value 2 since the rank
            of variable <i>m</i> is 2. The value of the expression <i>varindex[2]</i>
            depends on which matrix element is currently in the
            evaluation procedure, since it returns the second index of
            that element. For <i>m[2,1]</i> its value is 1, for <i>m[2,2]</i>
            its value is 2 and for <i>m[2,3]</i> its value is 3.
            Therefore, all components of <i>m[2,1]</i> will be assigned
            the value 2 + 3 * 1 = 5, all components of <i>m[2,2]</i>will

            be assigned the value 2 + 3 * 2 = 8, and all components of <i>m[2,3]</i>
            will be assigned the value 2 + 3 * 3 = 11. <br>
            &nbsp; <br>
            &nbsp; </p>
          <li> <a name="_Toc436572405"></a><b><font size="+1">varcomponent

              </font><i>[compnum ]</i></b></li>
          <br>
          Returns a specific component index (defined by <i>compnum</i>)
          of the variable element's component which is currently in the
          assigment procedure of a function like <b>setmatcomp</b>. The
          function can be called only in the specific situation where a
          component of a variable's element is being assigned by a
          function like <b>setmatcomp</b>.
          <p>If the value of <i>compnum</i> is zero, the function
            returns the number of dimensions of a variable element (e.g.
            2 for matrices, 1 for vectors, 0 for scalars). </p>
          <p><b>Example:</b> </p>
          <p>Let us have a matrix variable <i>m</i> of dimensions 3*2
            where all its elements are 2 by 2 matrices. and let us
            execute the command </p>
          <p><b><font size="+0">setmatcomp</font><i> { m[3] 10 *
                varindex[1] + varindex[2] + 0.1 * varcomponent[1] + 0.01
                * varcomponent[2] }</i></b> </p>
          <p>The command affects matrix elements <i>m[3,1]</i> and <i>m[3,2]</i>
            and sets their components to the following values: </p>
          <p><i>m[3,1]: {{31.11, 31.12}, {31.21, 31.22}}</i> </p>
          <p><i>m[3,2]: {{32.11, 32.12}, {32.21, 32.22}}</i> <br>
            &nbsp; <br>
            &nbsp;</p>
        </ol>
        <li> <a name="_Toc436572406"></a><b><i><font size="+2">Matrix
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Matrix variables hold matrix objects. These are
          two-dimensional arrays of decimal numbers. Both dimensions of
          an array are also a part of a matrix object. </p>
        <p>Elements of matrix variables can be empty (uninitialised)
          which means that they contain no data. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572407"></a><b><font size="+1">File
                Interpreter's Functions for Manipulation of Matrix
                Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol>
          <ol>
            <li> <a name="_Toc436572408"></a><b><font size="+1">newmatrix</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Creates a new matrix variable named <i>varname</i> with
            dimensions <i>dim1</i>, <i>dim2</i>, etc. It does not
            initialise variable elements. The rank of the created matrix
            variable equals the number of specified dimensions (<i>dim1</i>,
            <i>dim2</i>, etc.). If no dimensions are specified, a
            variable with rank 0 is created. If a matrix variable named
            <i>varname</i> already exists, it is firs deleted (together
            with its elements).
            <p><b>Explanation:</b> </p>
            <p>The shell's variables can hold multi-dimensional tables
              of objects of a given type (matrices in this case).
              Variable dimensions refer to the dimensions of such table,
              and variable rank is the number of these dimensions. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572409"></a><b><font size="+1">dimmatrix</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            The same a <b>newmatrix</b>, except that if a matrix
            variable named <i>varname</i> with proper dimensions
            already exists, it does not delete it. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572410"></a><b><font size="+1">setmatrix</font><i>
                  { elspec matspec }</i></b></li>
            <br>
            Sets a matrix element specified by <i>elspec</i> to the
            values specified by <i>matspec</i>. The specification of a
            matrix element <i>elspec</i> consists of a variable name
            and an optional index list in square brackets, e.g. <i>m1[2,3]</i>.
            The index list is not necessary if the rank of the matrix
            variable is 0.
            <p><i><u>elspec</u> must address an existing matrix element,
                except if no indices are specified</i>. In this case a
              matrix variable of rank 0 is created before the matrix
              element is set. </p>
            <p><i>matspec</i> specifies the contents, which are assigned
              to a matrix element. Matrix dimensions and components are
              normally specified in <i>matspec</i>. Alternatively, only
              dimensions, individual components, or groups of components
              can be specified in <i>matspec</i>. </p>
            <p>If matrix dimensions are specified in <i>matspec</i>,
              then if the matrix element specified by <i>elspec</i>
              already exists, but has wrong dimensions, it is deleted
              and created again with the right dimensions. If matrix
              element is not yet initialised, it is created anew. If it
              exists and has the right dimensions, it is not changed
              before the components are read. </p>
            <p>Just components can be specified in <i>matspec</i> only
              if the matrix element specified by <i>elspec</i> already
              exists with the right dimensions. </p>
            <p>All matrix components can be specified in <i>matspec</i>,
              but alternatively only one or only few components can be
              specified. In this case the components which are not
              specified remain the same. If these components have not
              been specified before, they will have indefinite values. </p>
            <p>The standard format of <i>matspec</i> is the following:
            </p>
            <p><i>dim1 dim2 { {1 1 : comp<sub>1,1</sub> } {1 2 : comp<sub>1,2</sub>
                } ... {2 1 : comp<sub>2,1</sub> } ... }</i> </p>
            <p>where <i>dim1</i> and <i>dim2</i> are the number of
              rows and columns, respectively, and <i>comp<sub>1,1</sub></i>,
              <i>comp<sub>1,2</sub></i>, etc., are matrix components. In
              the brackets where we specify components, component
              indices (i.e. the row number and the column number) are
              specified on the left side of a colon. </p>
            <p>Alternatively, whole rows are given in one bracket: </p>
            <p><i>dim1 dim2 { {1: comp<sub>1,1</sub> comp<sub>1,2</sub>
                ... } {2: comp<sub>2,1</sub> comp<sub>2,2</sub> ... }
                ... }</i> </p>
            <p>or components are just listed by turns, listing row by
              row: </p>
            <p><i>dim1 dim2 { comp<sub>1,1</sub> comp<sub>1,2</sub> ...
                comp<sub>2,1</sub> comp<sub>2,2</sub> ... ... }</i> </p>
            <p>If row and column numbers are specified with the
              components, then the order in which components are listed
              does not matter. Similarly, if only row numbers are
              specified, the order in which rows are listed does not
              matter. </p>
            <p>All numbers, which occur in the matspec, can be given by
              mathemathical expressions that are evaluated in the
              expression evaluator or by expression evaluator's
              variables. </p>
            <p><b>Examples:</b> </p>
            <p>Let us say that we have a matrix variable <i>m</i> of
              dimensions 2*3 and that we want to assign a 2 by 2 matrix
              to its element <i>m[1,3]</i>. Let the assigned matrix be
              a diagonal matrix with diagonal components set to 3.2. In
              a standard form this is done like this: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 {{1 1 : 3.2 } { 1 2 : 0
                } { 2 1 : 0 } { 2 2 : 3.2 } }</i> </p>
            <p>Instead individual components, whole rows can be listed
              in curlz brackets: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 {{1 : 3.2 0 } { 2 : 0
                3.2 } }</i> </p>
            <p>All components can be just listed without specifying
              their row and column numbers: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 { 3.2 0 0 3.2 } }</i> </p>
            <p>When component numbers are given, the order in which
              components are specified does not matter. The same matrix
              can also be set like this: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 {{ 1 2 : 0 } { 2 2 : 3.2
                } { 2 1 : 0 } {1 1 : 3.2 }}</i> </p>
            <p>or like this: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 {{ 2 : 0 3.2 } {1 : 3.2
                0 } }</i> </p>
            <p>If the matrix element is already initialised with proper
              dimensions, only components can be specified with the <b>setmatrix</b>
              command. This can be illustrated with an example where the
              dimensions and components are specified separately: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 }</i> </p>
            <p><b>setmatrix</b><i> { m[1 3] { 3.2 0 0 3.2 } }</i> </p>
            <p>With the first <b>setmatrix</b> command the matrix
              element dimensions are initialised, i.e. a matrix with two
              rows and two columns is created. With the second <b>setmatrix</b>
              command the componenets of the matrix element are set. We
              can furtherly split the setting of components into two
              parts: </p>
            <p><b>setmatrix</b><i> { m[1 3] 2 2 }</i> </p>
            <p><b>setmatrix</b><i> { m[1 3] { 3.2 0 } }</i> </p>
            <p><b>setmatrix</b><i> { m[1 3] { { 2: 0 3.2 } } }</i> </p>
            <p>With the second <b>setmatrix</b> command, only the first
              two matrix components were set. This means that the whole
              second row remained unset. We set this row with the third
              <b>setmatrix</b> command. </p>
            <p>All numbers in the <b>setmatrix</b> commands can be
              replaced by mathematical expressions or by calculator's
              variables. We can simply put <i>${expr}</i> or <i>$varname</i>
              in place of numbers, where <i>expr</i> is a mathematical
              expression that can be evaluated in the expression
              evaluator, and <i>varname</i> is a name of the expression
              evaluator's variable. This and the fact that we can set
              only dimensions and individual components by the <b>setmatrix</b>
              command enables additional matrix variables manipulation .
            </p>
            <p><b>Example:</b> </p>
            <p>Let us have a matrix variable of rank 0 named <i>m</i>.
              The following code creates an exact copy of <i>m</i>
              named <i>mc</i> regardless of the dimensions of <i>m</i>:
            </p>
            <p><font size="+0"><b>if</b> { ( getmatrix["m",0,1]&gt;0
                &amp;&amp; getmatrix["m",0,2]&gt;0 )</font> <br>
              <font size="+0">[</font> <br>
              <font size="+0"><b>setmatrix</b> { mc
                ${getmatrix["m",0,1]} ${getmatrix["m",0,2]}}</font> <br>
              <font size="+0"><b>=</b> {countrow:1}</font> </p>
            <p><font size="+0"><b>while</b> {
                (countrow&lt;=getmatrix["m",0,1])</font> <br>
              <font size="+0">[</font> <br>
              <font size="+0"><b>=</b> {countcol:1}</font> <br>
              <font size="+0"><b>while</b> {
                (countrow&lt;=getmatrix["m",0,2])</font> <br>
              <font size="+0">[</font> <br>
              <font size="+0"><b>setmatrix</b> { mc { {</font> <br>
              <font size="+0">$countrow $xountcol :</font> <br>
              <font size="+0">${getmatrix["m",countrow,countcol]}</font>
              <br>
              <font size="+0">} }</font> <br>
              <font size="+0">}</font> <br>
              <font size="+0"><b>=</b> {countcol:countcol+1}</font> <br>
              <font size="+0">] }</font> <br>
              <font size="+0"><b>=</b> {countrow:countrow+1}</font> <br>
              <font size="+0">] else</font> <br>
              <font size="+0">[</font> <br>
              <font size="+0"><b>newmatrix</b> { mc }</font> <br>
              <font size="+0">] }</font> <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572411"></a><b><font size="+1">copymatrixvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Copies the matrix variable named <i>varname1</i> to the
            variable named <i>varname2</i>. If the second matrix
            variable does not yet exist, it is created first. If it
            exists, it is overwritten. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572412"></a><b><font size="+1">movematrixvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Moves the matrix variable named <i>varname2</i> to the
            variable named <i>varname1</i>. If a matrix named <i>varname2</i>
            already exists, it is overwritten. After the operation the
            matrix variable named <i>varname1</i> no longer exists. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572413"></a><b><font size="+1">deletematrixvar</font><i>
                  { varname }</i></b></li>
            <br>
            Deletes the matrix variable named <i>varname</i>, together
            with its elements. After the operation the matrix variable
            named <i>varname</i> no longer exists. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572414"></a><b><font size="+1">printmatrixvar</font><i>
                  { varname }</i></b></li>
            <br>
            Prints the information (dimensions and components) about all
            matrix elements contained in the matrix variable named <i>varname</i>,
            to the standard output. General information about the matrix
            variable (e.g. rank and dimensions) is also printed. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572415"></a><b><font size="+1">fprintmatrixvar</font><i>
                  { varname }</i></b></li>
            <br>
            The same as the <b>printmatrix</b> function, except that it
            prints to the programme's output file. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572416"></a><b><font size="+1">copymatrix</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Copies a sub-table of matrix elements specified by <i>subspec1</i>
            to a sub-table specified by <i>subspec2</i>. Elements are
            copied one by one from the first sub-table to the
            appropriate places of the second sub-table. Dimensions of
            the sub-tables must be the same, except if the second
            specification (<i>subspec2</i>) refers to the whole element
            table of a matrix variable (i.e. the specification does not
            include an index list). In this case, the second variable is
            created anew if necessary. The old variable is in this case
            first deleted if it exists.
            <p>If the second sub-table already contains matrix elements,
              they are overwritten by the elements of the first
              sub-table. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572417"></a><b><font size="+1">movematrix</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            oves a sub-table of matrix elements specified by <i>subspec1</i>
            to a sub-table specified by <i>subspec2</i>. Elements are
            moved one by one from the first sub-table to the appropriate
            places of the second sub-table. Dimensions of the sub-tables
            must be the same, except if the second specification (<i>subspec2</i>)
            refers to the whole element table of a matrix variable (i.e.
            the specification does not include an index list). In this
            case, the second variable is created anew if necessary. The
            old variable is in this case first deleted if it exists.
            <p>If the second sub-table already contains matrix elements,
              they are overwritten by the elements of the first
              sub-table. After the operation, the first sub-table
              contains only empty (uninitialised) elements. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572418"></a><b><font size="+1">deletematrix</font><i>
                  { subspec }</i></b></li>
            <br>
            Deletes a sub-table of matrix elements specified by <i>subspec</i>.
            Matrices in the sub-table are deleted one by one. After the
            operation is performed, the sub-table contains only empty
            (non-initialised) elements.
            <p>If <i>subspec</i> specifies a whole table of elements of
              a matrix variable, the matrix variable itself is not
              deleted. Only its elements become empty (uninitialised). <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572419"></a><b><font size="+1">printmatrix</font><i>
                  { subspec }</i></b></li>
            <br>
            Prints information about elements of a sub-table of matrices
            specified by <i>subspec</i>. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572420"></a><b><font size="+1">fprintmatrix</font><i>
                  { subspec }</i></b></li>
            <br>
            Prints information about elements of a sub-table of matrices
            specified by <i>subspec</i> to the shell's output file (<i>outfile</i>).

            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572421"></a><b><font size="+1">setmatrixcomponents</font><i>
                  { subspec expr }</i>, shortly setmatcomp</b></li>
            <br>
            Sets the components of all matrices contained in the element
            sub-table specified by <i>subspec</i>, to the value of the
            expression <i>expr</i>. The expression <i>expr</i> is
            evaluated by the expression evaluator for each component
            separately. The function iterates over all matrices of the
            sub-table specified by <i>subspec</i> and over all
            components of these matrices and assigns them values
            specified by <i>expr</i>.
            <p>Two special expression evaluator's functions, <b>varindex</b>
              and <b>varcomponent</b> are designed for use with
              functions like <b>setmatcomp</b>. When the expressions <i>expr</i>
              is being evaluated for a specific component of a specific
              matrix element, the <b>varindex</b> function returns a
              specific index of the matrix element that is affected. The
              <b>varcomponent</b> function returns a specific component
              index (row or matrix number) of the component, which is
              currently in the evaluation procedure. </p>
            <p>Setting matrix components by the <b>setmatcomp</b>
              function is much quicker than doing it by programming
              loops which iterate over matrices of a variable's
              sub-table and over their components. This is because we
              avoid iterative calls of interpreter's functions. Instead,
              only one interpreter's function is called to do the job,
              the iteration loops are implemented in advance in this
              function and only the expression <i>exp</i> is evaluated
              again and again. The evaluation of this expression is very
              quick because it is parsed and interpreted outside the
              iteration loops. An already parsed and interpreted
              expression is evaluated within the iteration loops. </p>
            <p><b>Example:</b> </p>
            <p>Let us have a matrix variable <i>m</i> which contains
              5*2*3 matrices of dimension 5*2. Let us assign values to
              all components of the sub-table <i>m[4]</i> in such a way
              that component values will equal 100 times the first index
              of the sub-table element plus 10 times the second index of
              the sub-table element plus 0.1 times the row number plus
              0.01 times the column number of components. This is done
              by the command </p>
            <p><b><font size="+0">setmatcomp</font><i> { m[4] 100 *
                  varindex[2] + 10 * varindex[3] + 0.1 * varcomponent[1]
                  + 0.01 * varcomponent[2] }</i></b> <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572422"></a><b><font size="+1">matrixsum</font><i>
                  { subspec1 subspec2 subspecres }</i></b></li>
            <br>
            Adds together matrices from element tables specified by <i>subspec1</i>
            and <i>subspec2</i> and stores the results into matrices on
            the element table specified by <i>subspecres</i>.
            <p>The aim of this function is to demonstrate how binary
              operations on sub-tables of matrix variables work. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572423"></a><b><font size="+1">matrixop</font><i>
                  { spec = &lt; operator &gt; spec &lt; operator spec
                  &gt; }</i>,<i> </i>matop</b></li>
          </ol>
        </ol>
      </ol>
      <ol>
        <ol>
          <ol>
            Performs a matrix operation specified in the argument block.
            The operation specification consists of object
            specifications (matrix,&nbsp;&nbsp;&nbsp; vector and scalar
            objects) and operators.
            <ol>
              <ol>
                <ol>
                  &nbsp;
                </ol>
              </ol>
            </ol>
            This function performs some basic matrix and vector
            operations like multiplication and addition, evaluation of
            norms and determinants, matrix inversion, solution of
            systems of equatinos, etc.
            <p>One operation can be performed at a time. The argment
              block of the command is an expression which consists of
              object specifications (operands) and operators. Object
              specifications usually start with a two letter prefix
              which specifies the type of a specific object: s_ for
              scalars, v_ for vectors and m_ for matrices. This is
              followed by the specification of an element of a specific
              type, which is given by variable name and index list in
              square brackets. No spaces are allowed between the prefix
              which specifies object type and element specification.
              Element specification refers to a specific element of a
              user-defined variable. The operations can be performed
              only on individual elements (objects) within one call to
              the <b>matop</b> function, not on tables of elements. </p>
            <p>Sometimes the object specification is a mathematical
              expression which can be evaluated in the expression
              evaluator. In this case, the expression must be in curly
              brackets. </p>
            <p>Usually the operations which are performed produce some
              results which is stored in some object. In this case, in
              the argument block we gave first the specification of the
              object (variable element) into which the result is stored,
              followed by the assignment operator <i>=</i>. </p>
            <p>The following operations can be performed by the <b>matrixop</b>
              function: </p>
            <ul>
              <li> <b><i>matop{m_m0 = m_m1 + m_m2}</i></b> : matrix <i>m0</i>
                becomes the sum of matrices <i>m1</i> snd <i>m2</i>.</li>
              <li> <b><i>matop{m_m0 = m_m1 - m_m2}</i></b> :</li>
              <li> <b><i>matop{v_v0 = v_v1 + v_v2}</i></b> : vector <i>v0</i>
                becomes the sum of vectors <i>v1</i> and <i>v2</i>.</li>
              <li> <b><i>matop{v_v0 = v_v1 - v_v2}</i></b> : vector <i>v0</i>
                becomes the difference between matrices <i>v1</i> and <i>v2</i>.</li>
              <li> <b><i>matop{m_m0 = m_m1 * m_m2}</i></b> : matrix <i>m0</i>
                becomes the product of matrices <i>m1</i> snd <i>m2</i>.</li>
              <li> <b><i>matop{v_v0 = m_m1 * v_v2}</i></b> : vector <i>v0</i>
                becomes the product of vectors <i>v1</i> and <i>v2</i>.</li>
              <li> <b><i>matop{s_s0 = v_v1 * v_v2}</i></b> : Scalar
                variable <i>s0</i> becomes the scalar product of vector
                variables <i>v1</i> and <i>v2</i>.</li>
              <li> <b><i>matop{m_m0 = m_m1 * {expr}}</i></b> : Matrix <i>m0</i>
                becomes matrix <i>m1</i> multiplied by the value of the
                expression <i>expr</i>.</li>
              <li> <b><i>matop{v_v0 = v_v1 * {expr}}</i></b> : Vector <i>v0</i>
                becomes vector <i>v1</i> multiplied by the value of the
                expression <i>expr</i>.</li>
              <li> <b><i>matop{v_x = m_A solve v_b}</i></b> : Vector <i>x</i>
                becomes the solution of the equation A x = b</li>
              <li> <b><i>matop{m_m0 = transpose m_m1}</i></b> : Matrix
                <i>m0</i> becomes the transpose of the matrix <i>m1</i>.</li>
              <li> <b><i>matop{m_m0 = transpose v_v1}</i></b> : Matrix
                <i>m0</i> becomes th etranspose of the vector <i>v1</i>.</li>
              <li> <b><i>matop{m_m0 = invert m_m1}</i></b> : matrix <i>m0</i>
                becomes the inverse of th ematrix <i>m1</i>.</li>
              <li> <b><i>matop{s_s0 = norm m_m1}</i></b> : Scalar <i>s0</i>
                becomes the euclidian norm of the matrix <i>m1</i> (the
                square root of the sum of squares of components).</li>
              <li> <b><i>matop{s_s0 = norm v_v1}</i></b> : Scalar <i>s0</i>
                becomes the euclidian norm of the vector <i>v1</i>.</li>
              <li> <b><i>matop{m_m0 = normalize m_m1}</i></b> : Matrix
                <i>m0</i> becomes the normalised matrix <i>m1</i> (its
                component are divided by its norm).</li>
              <li> <b><i>matop{v_v0 = normalize v_v1}</i></b> : Vector
                <i>v0</i> becomes the normalized vector <i>v1</i>.</li>
              <li> <b><i>matop{m_m0 = identitymatrix {expr}}</i></b>
                Matrix <i>m0</i> becomes the identity square matrix of
                dimension that equals the value of the expression <i>expr</i>.</li>
              <li> <b><i>matop{m_m0 = zeromatrix {expr1} {expr2}}</i></b>
                : .Matrix <i>m0</i> becomes the zero matrix of
                dimensions that equal the values of the expressions <i>expr1</i>
                and <i>expr2</i>.</li>
              <li> <b><i>matop{m_m0 = randommatrix {expr1} {expr2}}</i></b>
                : Matrix <i>m0</i> becomes a matrix of dimensions that
                equal the values of the expressions <i>expr</i> and <i>expr1</i>
                with random components between 0 and 1. If only one
                expression is given, <i>mo</i> becomes a square matrix
                of the appropriate dimension.</li>
              <li> <b><i>matop{v_v0 = zerovector {expr}}</i></b> :
                Vector <i>v0</i> becomes a yero vector of the dimension
                that equals the value of the expression <i>expr</i>.</li>
              <li> <b><i>matop{v_v0 = randomvector {expr}}</i></b> :
                Vector <i>v0</i> becomes a zero vector of the dimension
                that equals the value of the expression <i>expr</i>.</li>
            </ul>
            <b>Examples</b>
            <p><i>matop { m_m1[2,3] = transpose m_a0[1] }</i> <br>
              &nbsp; <br>
              &nbsp;</p>
          </ol>
        </ol>
      </ol>
      <ol>
        <ol start="2">
          <li> <a name="_Toc436572424"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating Matrix Variables</font></b></li>
          <br>
          &nbsp;
          <ol>
            <li> <a name="_Toc436572425"></a><b><font size="+1">getmatrix</font><i>
                  { varname &lt; elind1, elind2, ... &gt; rownum colnum
                  }</i></b></li>
            <br>
            Returns a specific matrix component. <i>varname</i> is the
            name of a matrix variable. <i>elind1</i>, <i>elind2</i>,
            etc., are the indices, which specify the matrix element on
            the variable's element table. <i>rownum</i> is the row
            number and <i>colnum</i> is the column number of the
            component, which is returned.
            <p>If the variable named <i>varname</i> is of rank 0, then
              no indices <i>elind1</i>, <i>elind2</i>, etc. need to be
              specified. </p>
            <p>If <i>rownim</i> is 0, the function returns number of
              rows of the matrix if <i>colnum</i> is 1, or number of
              columns of the matrix if <i>colnum</i> is 2. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572426"></a><b><font size="+1">getmartixdim</font><i>
                  { varname dimnum }</i></b></li>
            <br>
            Returns the <i>dimnum</i>-th dimension of the matrix
            variable named <i>varname</i>. If <i>dimnum</i> is 0, it
            returns the rank of the variable.
          </ol>
        </ol>
      </ol>
    </ol>
    <br>
    &nbsp; <br>
    &nbsp;
    <ol>
      <ol start="6">
        <li> <a name="_Toc436572427"></a><b><i><font size="+2">Vector
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Vector objects are one-dimensional arrays of decimal numbers.
          The dimension of an array is also a part of a vector object. </p>
        <p>Elements of vector variables can be empty (uninitialised)
          which means that they contain no data. The dimension and
          components of such elements are not defined. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572428"></a><b><font size="+1">File
                Interpreter's Functions for Manipulating Vector
                Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572429"></a><b><font size="+1">newvector</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Does the same as <b>newmatrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572430"></a><b><font size="+1">dimvector</font><i><font
                    size="-1"> { varname &lt; [ dim1, dim2, ... ] &gt; }</font></i></b></li>
            <br>
            Does the same as<b>dimmatrix</b>, but for vector variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572431"></a><b><font size="+1">setvector</font><i><font
                    size="-1"> { elspec vecspec }</font></i></b></li>
            <br>
            This function is similar to the corresponding matrix
            function <b>setmatrix</b>. It sets a vector element
            specified by <i>elspec</i> to the values specified by <i>vecspec</i>.
            The specification of a vector element <i>elspec</i>
            consists of a variable name and an optional index list in
            square brackets, e.g. <i>v1[2,3]</i>. The index list is not
            necessary if the rank of the vector variable is 0.
            <p><i>elspec</i> must address an existing vector element,
              except if no indices are specified. In this case a vector
              variable of rank 0 is created before the vector element is
              set. </p>
            <p><i>vecspec</i> specifies the contents which are assigned
              to the vector element. Vector dimension and components are
              normally specified in <i>vecspec</i>. Alternatively, only
              the dimension, individual components, or groups of
              components can be specified in <i>vecspec</i>. </p>
            <p>If vector dimensions are specified in <i>vecspec</i>,
              then if the vector element specified by <i>elspec</i>
              already exists, but have a wrong dimension, it is deleted
              and created again with the right dimension. If vector
              element is not yet initialised, it is created anew. If it
              exists and has the right dimension, it is not changed
              before the components are read. </p>
            <p>Just components can be specified in <i>vecspec</i> only
              if the vector element specified by <i>elspec</i> already
              exists with the right dimension. </p>
            <p>All vector components can be specified in <i>vecspec</i>,
              but alternatively only one or only few components can be
              specified. In this case the unspecified components remain
              the same. If the components have not been specified
              before, their values will be indefinite. </p>
            <p>The standard format of <i>vecspec</i> is the following:
            </p>
            <p><i>dim { {1 : comp<sub>1</sub> } { 2 : comp<sub>2</sub> }
                { 3 : comp<sub>3</sub> } ... }</i> </p>
            <p>where <i>dim</i> is vector dimension (the number of
              rcomponents), and <i>comp<sub>1</sub></i>, <i>comp<sub>2</sub></i>,
              etc., are vector components. In the brackets where we
              specify components, the component numbers are specified on
              the left side of a colon. </p>
            <p>Alternativaly, the components are just lister by turns: </p>
            <p><i>dim { comp<sub>1</sub> comp<sub>2</sub> comp<sub>3</sub>
                ... }</i> </p>
            <p>If the component numbers are specified with the
              components, then the order in which components are listed
              does not matter. </p>
            <p>All numbers that occur in the <i>vecspec</i> can be
              given by mathemathical expressions that are evaluated in
              the expression evaluator or by expression evaluator's
              variables. </p>
            <p><b>Examples:</b> </p>
            <p>Let us say that we have a vector variable <i>v</i> of
              dimensions 2*3 and that we want to assign a 4 dimensional
              vector to its element <i>v[1,3]</i>. Let the assigned
              vector components have values 1.1, 2.2, 3.3 and 4.4. In a
              standard form this is done like this: </p>
            <p><b>setvector</b><i> { v[1 3] 4 { {1 : 1.1 } { 2 : 2.2 } {
                3 : 3.3 } { 4 : 4.4 } }</i> </p>
            <p>All components can be just listed without specifying
              their component numbers: </p>
            <p><b>setvector</b><i> { v[1 3] 4 { 1.1 2.2 3.3 4.4 } }</i>
            </p>
            <p>When component numbers are given, the order in which
              components are specified does not matter. The same vector
              can also be set like this: </p>
            <p><b>setvector</b><i> { v[1 3] 4 { { 3 : 3.3 } {1 : 1.1 } {
                4 : 4.4 } { 2 : 2.2 } }</i> </p>
            <p>If a vector element is already initialised with proper
              dimensions, only components can be specified with the <b>setmatrix</b>
              command. This can be illustrated with an example where the
              dimensions and components are specified separately: </p>
            <p><b>setvector</b><i> { v[1 3] 4 }</i> </p>
            <p><b>setvector</b><i> { v[1 3] { 1.1 2.2 3.3 4.4 } }</i> </p>
            <p>With the first <b>setvector</b> command the vector
              element dimension is initialised, i.e. a vector with four
              components is created. With the second <b>setvector</b>
              command the componenets of the vector element are set. We
              can furtherly split the setting of components into two
              parts: </p>
            <p><b>setvector</b><i> { v[1 3] 4 }</i> </p>
            <p><b>setvector</b><i> { v[1 3] { 1.1 2.2 } }</i> </p>
            <p><b>setvector</b><i> { v[1 3] { { 3 : 3.3 } { 4 : 4.4 } }
                }</i> </p>
            <p>With the second <b>setvector</b> command, only the first
              two vector components were set. The rest components were
              set by the third <b>setvector</b> command. </p>
            <p>All numbers in the <b>setvector</b> commands can be
              replaced by mathematical expressions or by calculator's
              variables. We can simply put <i>${expr}</i> or <i>$varname</i>
              in place of numbers, where <i>expr</i> is a mathematical
              expression that can be evaluated in the expression
              evaluator, and <i>varname</i> is a name of an expression
              evaluator's variable. This and the fact that we can set
              only dimensions and individual components by the <b>setvector</b>
              command enables additional vector variables manipulation .
            </p>
            <p><b>Example:</b> </p>
            <p>The following code creates a zero rank vector variable <i>tab</i>
              which holds a table of valuesof the exponential function
              on the interval [0,1] with step 1: </p>
            <p><font size="+0"><b>=</b> {currentx: 0}</font> </p>
            <p><font size="+0"><b>=</b> {lastx: 10}</font> </p>
            <p><font size="+0"><b>=</b> {step: 1}</font> </p>
            <p><font size="+0"><b>=</b> {dim: 11}</font> </p>
            <p><font size="+0"><b>setvector</b> {tab dim}</font> </p>
            <p><font size="+0"><b>=</b> {compnum : 1}</font> </p>
            <p><font size="+0"><b>while</b> { (currentx&lt;=lastx)</font>
            </p>
            <p><font size="+0">[</font> </p>
            <p><font size="+0"><b>setvector</b> {tab { { $compnum :
                exp[currentx] } }}</font> </p>
            <p><font size="+0"><b>=</b> {currentx:currentx+step}</font>
            </p>
            <p><font size="+0"><b>=</b> {compnum:compnum+1}</font> </p>
            <p><font size="+0">] }</font> <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572432"></a><b><font size="+1">copyvectorvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>copymatrixvar</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572433"></a><b><font size="+1">movevectorvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>movematrixvar</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572434"></a><b><font size="+1">deletevectorvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>deletematrixvar</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572435"></a><b><font size="+1">printvectorvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572436"></a><b><font size="+1">fprintvectorvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>frintmatrixvar</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572437"></a><b><font size="+1">copyvector</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>copymatrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572438"></a><b><font size="+1">movevector</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>movematrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572439"></a><b><font size="+1">deletevector</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>deletematrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572440"></a><b><font size="+1">printvector</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>printmatrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572441"></a><b><font size="+1">fprintvector</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>fprintmatrix</b>, but for vector
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572442"></a><b><font size="+1">setvectorcomponents</font><i>
                  { subspec expr }</i>, shortly setveccomp</b></li>
            <br>
            This function is similar to its matrix equivalent <b>setmatcomp</b>.
            It sets the components of all vectors contained in the
            element sub-table specified by <i>subspec</i>, to the value
            of the expression <i>expr</i>. The expression <i>expr</i>
            is evaluated by the expression evaluator for each compponent
            separately. The function iterates over all vectors of the
            sub-table specifiefd by <i>subspec</i> and over all
            components of these vectors and assignes them values
            specified by <i>expr</i>.
            <p>Two special expression evaluator's functions, <b>varindex</b>
              and <b>varcomponent</b> are designed for use with
              functions like <b>setveccomp</b>. When the expressions <i>expr</i>
              is being evaluated for a specific component of a specific
              vector element, the <b>varindex</b> function returns a
              specific index of the vector element that is affected. The
              <b>varcomponent</b> function returns the number of the
              component which is currently in the evaluation procedure.
              It must be called with argument 1, although vector objects
              have only one dimension anyway (because of compatibility
              reasons). </p>
            <p>Setting vector components by the <b>setveccomp</b>
              function is much quicker than doing it by programming
              loops which iterate over vectors of a variable's sub-table
              and over their components. This is because we avoid
              iterative calls to interpreter's functions. Instead, only
              one interpreter's function is called to do the job, the
              iteration loops are implemented in advance in this
              function and only the expression <i>exp</i> is evaluated
              again and again. The evaluation of this expression is very
              quick because it is parsed and interpreted outside the
              iteration loops. </p>
            <p><b>Example:</b> </p>
            <p>Let us have a vector variable <i>v</i> which contains
              6*3*4 vectors of dimension 10. Let us assign values to all
              components of the sub-table <i>v[3]</i> in such a way
              that component values will equal 10 times the first index
              of the sub-table element plus the second index of the
              subtable element plus 0.1 times the component number. This
              is done by the command </p>
            <p><b><font size="+0">setveccomp</font><i> { v[3] 10 *
                  varindex[2] + varindex[3] + 0.1 * varcomponent[1] }</i></b>
              <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572443"></a><b><font size="+1">vectorsum</font><i>
                  { subspec1 subspec2 subspecres }</i></b></li>
            <br>
            Does the same as <b>matrixsum</b>, but for vector
            variables. The aim of this function is mostly to demonstrate
            how binary operations on variable sub-tables work.
          </ol>
          <br>
          &nbsp;
          <li> <a name="_Toc436572444"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating Vector Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572445"></a><b><font size="+1">getvector</font><i>
                  { varname &lt; elind1, elind2, ... &gt; compnum }</i></b></li>
            <br>
            Returns a specific vector component. <i>varname</i> is the
            name of a vector variable. <i>elind1</i>, <i>elind2</i>,
            etc., are the indices which specify the vector element on
            the variable's element table. <i>compnum</i> is the number
            of the component which is returned.
            <p>If the variable named <i>varname</i> is of rank 0, then
              no indices <i>elind1</i>, <i>elind2</i>, etc. do not
              need to be specified. </p>
            <p>If <i>compnum</i> is 0, then the function returns the
              dimension (number of components) of the vector element. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572446"></a><b><font size="+1">getvectordim</font><i>
                  { varname dimnum }</i></b></li>
            <br>
            The same as <b>getmatrixdim</b>, but for vector variables.
          </ol>
        </ol>
        <br>
        &nbsp; <br>
        &nbsp;
        <li> <a name="_Toc436572447"></a><b><i><font size="+2">Scalar
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Scalar objects are simply decimal numbers. </p>
        <p>Elements of scalar variables can be empty (uninitialised)
          which means that they contain no data, the same as elements of
          vector or matrix variables.. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572448"></a><b><font size="+1">File
                Interpreter's Functions for Manipulating Scalar
                Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572449"></a><b><font size="+1">newscalar</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Does the same as <b>newmatrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572450"></a><b><font size="+1">dimscalar</font><i><font
                    size="-1"> { varname &lt; [ dim1, dim2, ... ] &gt; }</font></i></b></li>
            <br>
            Does the same as<b>dimmatrix</b>, but for scalar variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572451"></a><b><font size="+1">setscalar</font><i><font
                    size="-1"> { elspec scalspec }</font></i></b></li>
            <br>
            Sets a scalar element specified by <i>elspec</i> to the
            value specified by <i>scalspec</i>. The specification of a
            scalar element <i>elspec</i> consists of a variable name
            and an optional index list in square brackets, e.g. <i>s1[2,3]</i>.
            The index list is not necessary if the rank of the scalar
            variable is 0.
            <p><i>elspec</i> must address an existing scalar element,
              except if no indices are specified. In this case a scalar
              variable of rank 0 is created before the scalar element is
              set. </p>
            <p><i>scalspec</i> specifies the value which is assigned to
              the scalar object. It can be given as a number, as a
              mathematical expression that can be evaluated by the
              expression evaluator, or as an expression evaluator's
              variable. Expressions in place of numbers must be of the
              form <i>${expr}</i> where <i>expr</i> is a mathematical
              expression, and calculator's variables in place of numbers
              must be of the form <i>$varname</i>, where <i>varname</i>
              is the calculator's variable name. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572452"></a><b><font size="+1">copyscalarvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>copymatrixvar</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572453"></a><b><font size="+1">movescalarvar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>movematrixvar</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572454"></a><b><font size="+1">deletescalarvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>deletematrixvar</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572455"></a><b><font size="+1">printscalarvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572456"></a><b><font size="+1">fprintscalarvar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572457"></a><b><font size="+1">copyscalar</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>copymatrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572458"></a><b><font size="+1">movescalar</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>movematrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572459"></a><b><font size="+1">deletescalar</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>deletematrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572460"></a><b><font size="+1">printscalar</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>printmatrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572461"></a><b><font size="+1">printscalar</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>fprintmatrix</b>, but for scalar
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572462"></a><b><font size="+1">setscalarcomponents</font><i>
                  { subspec expr }</i>, shortly setscalcomp</b></li>
            <br>
            This function is similar to its matric equivalent <b>setmatcomp</b>.
            It sets the values of all scalars contained in the element
            sub-table specified by <i>subspec</i>, to the value of the
            expression <i>expr</i>. The expression <i>expr</i> is
            evaluated by the expression evaluator for each scalar
            separately.
            <p>A special expression evaluator's function <b>varindex</b>
              is designed for use with functions like <b>setscalcomp</b>.
              When the expressions <i>expr</i> is being evaluated for a
              specific scalar element, the <b>varindex</b> function
              returns a specific index of the scalar element that is
              affected. </p>
            <p>It makes sense to use this function only with scalar
              variables with rank greater than zero, especially if they
              contain a large number of scalars. It is differently with
              matrix and vector variables where element themselves hold
              more components. </p>
            <p>The <b>varcomponent</b> function can not be used woth <b>setscalcomp</b>
              since scalars are simple objects without components. </p>
            <p><b>Varning:</b> </p>
            <p>The <b>setscalcomp</b> <u>function assigns values only
                to those scalars which are initialised</u>. It has no
              effect if it is performed on a sub-table the elements of
              which are not initialised. Note that <u>functions which
                create scalar variables</u> like <b>newscalar</b> or <b>dimscalar</b>
              <u>usually do not initialise the scalars on variable's
                element table</u>. </p>
            <p><b>Example:</b> </p>
            <p>Let us have a scalar variable <i>s</i> which contains
              2*3*4 scalars. Let us assign values to all components of
              the sub-table <i>s[2]</i> in such a way that scalar
              values will equal 10 times the first index of the
              sub-table element plus the second index of the sub-table
              element. This is done by the command </p>
            <p><b><font size="+0">setscalcomp</font><i> { s[3] 10 *
                  varindex[2] + varindex[3] }</i></b> <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572463"></a><b><font size="+1">scalarsum</font><i>
                  { subspec1 subspec2 subspecres }</i></b></li>
            <br>
            Does the same as <b>matrixsum</b>, but for scalar
            variables. The aim of this function is mostly to demonstrate
            the use of binary operations performed on sub-table of
            variable's elements.
          </ol>
          <br>
          &nbsp;
          <li> <a name="_Toc436572464"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating Scalar Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572465"></a><b><font size="+1">getscalar</font><i>
                  { varname &lt; elind1, elind2, ... &gt; }</i></b></li>
            <br>
            Returns the value of a specific scalar object. <i>varname</i>
            is the name of a scalar variable. <i>elind1</i>, <i>elind2</i>,
            etc., are the indices which specify the scalar element on
            the variable's element table.
            <p>If the variable named <i>varname</i> is of rank 0, then
              no indices <i>elind1</i>, <i>elind2</i>, etc. do not
              need to be specified. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572466"></a><b><font size="+1">getscalardim</font><i>
                  { varname dimnum }</i></b></li>
            <br>
            The same as <b>getmatrixdim</b>, but for scalar variables.
          </ol>
        </ol>
        <br>
        &nbsp; <br>
        &nbsp;
        <li> <a name="_Toc436572467"></a><b><i><font size="+2">Counter
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Counter objects are integer numbers. </p>
        <p>Elements of counter variables can be empty (uninitialised)
          which means that they contain no data, the same as elements of
          vector or matrix variables. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572468"></a><b><font size="+1">File
                Interpreter's Functions for Manipulating Counter
                Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572469"></a><b><font size="+1">newcounter</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Does the same as <b>newmatrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572470"></a><b><font size="+1">dimcounter</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Does the same as<b>dimmatrix</b>, but for counter variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572471"></a><b><font size="+1">setcounter</font><i>
                  { elspec countspec }</i></b></li>
            <br>
            Sets a counter element specified by <i>elspec</i> to the
            value specified by <i>countspec</i>. The specification of a
            counter element <i>elspec</i> consists of a variable name
            and an optional index list in square brackets, e.g. <i>cc[2,3]</i>.
            The index list is not necessary if the rank of the counter
            variable is 0.
            <p><i>elspec</i> must address an existing counter element,
              except if no indices are specified. In this case a counter
              variable of rank 0 is created before the counter element
              is set. </p>
            <p><i>countspec</i> specifies the value which is assigned to
              the counter object. It can be given as a number, as a
              mathematical expression that can be evaluated by the
              expression evaluator, or as an expression evaluator's
              variable. Expressions in place of numbers must be of the
              form <i>${expr}</i> where <i>expr</i> is a mathematical
              expression, and calculator's variables in place of numbers
              must be of the form <i>$varname</i>, where <i>varname</i>
              is the calculator's variable name. </p>
            <p><b>Warning:</b> </p>
            <p><i>countspec</i> can also result in a decimal. In this
              case, it is first rounded and then assigned to the
              appropriate element of a counter variable. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572472"></a><b><font size="+1">copycountervar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>copymatrixvar</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572473"></a><b><font size="+1">movecountervar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>movematrixvar</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572474"></a><b><font size="+1">deletecountervar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>deletematrixvar</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572475"></a><b><font size="+1">printcountervar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572476"></a><b><font size="+1">fprintcountervar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>fprintmatrixvar</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572477"></a><b><font size="+1">copycounter</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>copymatrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572478"></a><b><font size="+1">movecounter</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>movematrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572479"></a><b><font size="+1">deletecounter</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>deletematrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572480"></a><b><font size="+1">printcounter</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>printmatrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572481"></a><b><font size="+1">fprintcounter</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>fprintmatrix</b>, but for counter
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572482"></a><b><font size="+1">setcountercomponents</font><i>
                  { subspec expr }</i>, shortly setcountcomp</b></li>
            <br>
            This function is similar to its matric equivalent <b>setscalcomp</b>.
            It sets the values of all counters contained in the element
            sub-table specified by <i>subspec</i>, to the value of the
            expression <i>expr</i>. The expression <i>expr</i> is
            evaluated by the expression evaluator for each counter
            separately.
            <p>A special expression evaluator's function <b>varindex</b>
              is designed for use with functions like <b>setcountcomp</b>.
              When the expressions <i>expr</i> is being evaluated for a
              specific counter element, the <b>varindex</b> function
              returns a specific index of the counter element that is
              affected. </p>
            <p>It makes sense to use this function only with counter
              variables with rank greater than zero, especially if they
              contain a large number of counters. It is differently with
              matrix and vector variables where element themselves hold
              more components. </p>
            <p>The <b>varcomponent</b> function can not be used woth <b>setcountcomp</b>
              since counters are simple objects without components. </p>
            <p><b>Varning:</b> </p>
            <p>The <b>setcountcomp</b> <u>function assigns values only
                to those counters which are initialised</u>. It has no
              effect if it is performed on a sub-table the elements of
              which are not initialised. Note that <u>functions which
                create counter variables</u> like <b>newcounter</b> or
              <b>dimcounter</b><u>usually do not initialise the counters
                on variable's element table</u>. </p>
            <p><b>Example:</b> </p>
            <p>Let us have a counter variable <i>c</i> which contains
              2*3*4 counters. Let us assign values to all components of
              the sub-table <i>c[2]</i> in such a way that counter
              values will equal 10 times the first index of the
              sub-table element plus the second index of the sub-table
              element. This is done by the command </p>
            <p><b><font size="+0">setcountcomp</font><i> { c[3] 10 *
                  varindex[2] + varindex[3] }</i></b> <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572483"></a><b><font size="+1">countersum</font><i>
                  { subspec1 subspec2 subspecres }</i></b></li>
            <br>
            Does the same as <b>matrixsum</b>, but for counter
            variables. The aim of this function is mostly to demonstrate
            the use of binary operations performed on sub-table of
            variable's elements.
          </ol>
          <br>
          &nbsp;
          <li> <a name="_Toc436572484"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating Counter Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol>
          <ol>
            <li> <a name="_Toc436572485"></a><b><font size="+1">getcounter</font><i>
                  { varname &lt; elind1, elind2, ... &gt; }</i></b></li>
            <br>
            Returns the value of a specific counter object. <i>varname</i>
            is the name of a counter variable. <i>elind1</i>, <i>elind2</i>,
            etc., are the
            <p>indices which specify the counter element on the
              variable's element table. </p>
            <p>If the variable named <i>varname</i> is of rank 0, then
              no indices <i>elind1</i>, <i>elind2</i>, etc. do not
              need to be specified. </p>
            <li> <a name="_Toc436572486"></a><b><font size="+1">getcounterdim</font><i>
                  { varname dimnum }</i></b></li>
            <br>
            The same as <b>getmatrixdim</b>, but for counter variables.
          </ol>
        </ol>
        <br>
        &nbsp;
        <li> <a name="_Toc436572487"></a><b><i><font size="+2">Options</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Oprions are object that can have two values:0 or 1. We also
          say that they are unset (value 0) or set (value 1). Usually
          they are used to control behaviour of various functions of the
          shell. </p>
        <p>No special type of variables is prepared for carrying
          options. Rather than that, options are hold by counter
          variables. An option hold in a counter variable is considered
          to be 0 if the appropriate counter is 0, and 1 if the
          appropriate counter is different than zero. </p>
        <p>If a counter that represents a specific option does not exist
          or is not initialised, the appropriate option is considered to
          be 0. </p>
        <p>Actually, the file interpreter's and expression evaluator's
          functions for manipulating counter variables could be used for
          handling options. Nevertheless, there are a few functions that
          are created especially for setting options and checking their
          status. The main reason for that is maintaining greater
          clarity of the code in the command file. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572488"></a><b><font size="+1">File
                Interpreter's Functions for Handling Options</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572489"></a><b><font size="+1">setoption</font><i>
                  { optspec }</i></b></li>
            <br>
            Sets the option specified by <i>optspec</i>. <i>optspec</i>
            is the specification of the counter element that represents
            the option. The appropriate counter element is set to 1. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572490"></a><b><font size="+1">clearoption</font><i>
                  { optspec }</i></b></li>
            <br>
            Clears the option specified by <i>optspec</i>. <i>optspec</i>
            is the specification of the counter element that represents
            the option. The appropriate counter element is set to 0 if
            it exists, otherwise nothing happens. <br>
            &nbsp; <br>
            &nbsp;
          </ol>
          <li> <a name="_Toc436572491"></a><b><font size="+1">Expression

                Evaluator's Functions for Handling Options</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol>
          <ol>
            <li> <a name="_Toc436572492"></a><b><font size="+1">getoption</font><i>
                  { varname &lt; elind1, elind2, ... &gt; }</i></b></li>
            <br>
            Returns 1 if the specified option is set and 0 if it is not
            set. <i>varname</i> is the name of a counter variable. <i>elind1</i>,
            <i>elind2</i>, etc., are the indices which specify the
            counter element that holds the option, on the variable's
            element table. If the counter variable named <i>varname</i>
            is of rank 0, then no indices <i>elind1</i>, <i>elind2</i>,
            etc. do not need to be specified.
            <p>A specific option is considered to be set, if the
              appropriate counter element exists, is initialised and is
              different than zero. Otherwise, this option is considered
              to be unset. <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp;</p>
          </ol>
        </ol>
        <li> <a name="_Toc436572493"></a><b><i><font size="+2">Field
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <br>
        &nbsp;
      </ol>
      <ol start="6">
        <ol>
          <li> <a name="_Toc443456721"></a><b><font size="+1">File
                Interpreter's Functions for Manipulating Field Variables</font></b></li>
          <br>
          &nbsp;
        </ol>
        <ol>
          <ol>
            <li> <a name="_Toc436572494"></a><a name="_Toc443456722"></a><b><font
                  size="+1">newfield</font></b><i> {varname &lt; [dim1,
                dim2,...]&gt; }</i></li>
            <br>
            Does the same as <b>newmatrix</b>, but for field variables.
            <br>
            &nbsp;
            <li> <a name="_Toc436572495"></a><a name="_Toc443456723"></a><b><font
                  size="+1">dimfield<i> </i></font></b><i>{ varname
                &lt; [dim1, dim2,...]&gt; }</i></li>
            <br>
            Does the same as <b>dimmatrix</b>, but for field variables.
            <br>
            &nbsp;
            <li> <a name="_Toc443456724"></a><b><font size="+1">setfield
                </font><i>{elspec
                  fieldspec }</i></b></li>
            <br>
            Does the same as <b>setmatrix</b>, but for field variables.
            <br>
            &nbsp;
            <li> <a name="_Toc443456725"></a><b><font size="+1">initfield
                </font><i>{subspec
                  fieldspec }</i></b></li>
            <br>
            Does the same as <b>initmatrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456726"></a><b><font size="+1">copyfieldvar</font><i>{
                  varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>copymatrixvar</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456727"></a><b><font size="+1">movefieldvar</font><i>{
                  varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>movematrixvar</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456728"></a><b><font size="+1">deletefieldvar</font><i>{
                  varname }</i></b></li>
            <br>
            Does the same as <b>deletematrixvar</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456729"></a><b><font size="+1">printfieldvar</font><i>{
                  varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456730"></a><b><font size="+1">fprintfieldvar</font><i>{
                  varname }</i></b></li>
            <br>
            oes the same as <b>fprintmatrixvar</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456731"></a><b><font size="+1">copyfield</font><i>{
                  subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>copymatrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456732"></a><b><font size="+1">movefield</font><i>{
                  subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>movematrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456733"></a><b><font size="+1">deletefield</font><i>{
                  subspec }</i></b></li>
            <br>
            Does the same as <b>deletematrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456734"></a><b><font size="+1">printfield</font><i>{
                  subspec }</i></b></li>
            <br>
            Does the same as <b>printmatrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456735"></a><b><font size="+1">fprintfield</font><i>{
                  subspec }</i></b></li>
            <br>
            Does the same as <b>fprintmatrix</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456736"></a><b><font size="+1">setfieldcomponents</font><i>{
                  subspec expr }</i></b></li>
            <br>
            Does the same as <b>setmatrixcomponents</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456737"></a><b><font size="+1">setfldcompcond</font><i>{
                  subspec (cond) expr }</i></b></li>
            <br>
            Does the same as <b>setmatcompcond</b>, but for field
            variables. <br>
            &nbsp;
            <li> <a name="_Toc443456738"></a><b><font size="+1">filereadfieldcomp</font><i>
                  { filespec fieldspec &lt;lin col&gt; &lt;next&gt; }</i></b></li>
            <br>
            Function reads an array of numbers from an arbitrary file at
            the current position and stores its components to a
            programme's <i>field variable</i>. The first argument of
            the function (<i>fieldspec</i>) is a specification of the
            field variable. Standard form of the variable specification
            consists of the variable name and optionally the index table
            in square brackets. Arguments <i>lin</i>, <i>col</i> and <i>next</i>
            are optional. By specifying arguments <i>lin</i> and <i>col</i>
            user sets the dimension of the field variable where the
            array components are stored to. These arguments must always
            be specified together. If they are not specified, field
            variable dimension is set to the dimension of the array
            found in the input file. If optional argument <i>next</i>
            is specified, the position of the first byte after the last
            array component is assigned to the expression evaluator's
            variable with the same name. <br>
            Reading of the array components starts at the current
            position in the file. If <i>filespec</i> is not defined, an
            error report is written to the standard output and to the
            programme's output file. If field variable <i>fieldspec</i>
            is not defined, a new field variable with name <i>fieldspec</i>
            and rank 0 is created. This action is reported to the
            standard output and to the programme's output file. If
            creating is not successful an error report is written to the
            standard output and to the programme's output file. If field
            variable <i>fieldspec</i> exists its contents is
            overwritten at function call. If arguments <i>lin</i> and <i>col</i>
            are specified and the dimensions of the field variable is
            greater than the dimensions of the actual array in the input
            file, <i>fieldspec gets NULL</i> value. If number of
            arguments is smaller than 2 or greater than 5 an error
            report is written to the standard output and to the
            programme's output file. <br>
            &nbsp;
            <li> <a name="_Toc443456739"></a><b><font size="+1">filewritefieldcomp

                </font><i>{ filespec fieldspec }</i></b></li>
            <br>
            Appends field components stored in field variable <i>fieldspec</i>
            to an arbitrary file <i>filespec</i>. File <i>filespec</i>
            has to be opened for writing. The output is formatted as an
            array of numbers delimited by spaces. Dimensions of the
            array are the same as the dimensions of the field variable <i>fieldspec</i>
            (<i>lin </i>x<i> col</i>).
          </ol>
        </ol>
        <ul>
          <ol start="19">
            Possible errors that can occur are:
            <ul>
              <li> output file <i>filespec</i> is not defined</li>
              <li> field variable <i>fieldspec</i> is not defined</li>
            </ul>
            In both cases an error report is written to the standard
            output and to the programme's output file. <br>
            &nbsp;
            <li> <a name="_Toc443456740"></a><b><font size="+1">filereplacefield

                </font><i>{ filespec fieldspec fieldname searchpos
                  &lt;start&gt;}</i></b></li>
            <br>
            Searches for the first field with name <i>fieldname</i> in
            an arbitrary input file <i>filespec</i> from position <i>searchpos</i>
            on and replaces its components by components stored in field
            variable <i>fieldspec</i>. <i>start</i> is an optional
            argument. If it is specified, the position of the beginning
            of an array of field components is assigned to the
            expression evaluator's variable with the same name.
          </ol>
        </ul>
        <ul>
          <ul>
            Possible errors that can occur are:
            <ul>
              <li> input file <i>filespec</i> is not defined</li>
              <li> field variable <i>fieldspec</i> is not defined</li>
              <li> string <i>fieldname</i> is not found between
                position <i>searchpos</i> and EOF</li>
              <li> number of arguments is not equal 4 or 5</li>
            </ul>
            In all of these cases an error report is written to the
            standard output and to the programme's output file.
          </ul>
        </ul>
        <br>
        &nbsp;
        <ol>
          <li> <a name="_Toc443456741"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating Field Variables</font></b><br>
            <br>
          </li>
          <ol>
            <li> <a name="_Toc443456742"></a><b><font size="+1">getfield</font><i>{varname
&lt;elind1,

                  elind2,...&gt; rownum colnum }</i></b></li>
            <br>
            Does the same as g<b>etmatrix</b>, but for field variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc443456743"></a><b><font size="+1">getfielddim</font><i>{varname
dimnum

                  }</i></b></li>
            <br>
            Does the same as g<b>etmatrix</b>, but for field variables.
          </ol>
        </ol>
        <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp;
        <li> <a name="_Toc436572496"></a><b><i><font size="+2">File
                Variables</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>File objects are sused in the shell to establish the
          connection with files on the disk. File objects hold basic
          information about files, i.e. the file pointer, the file name,
          the current position, and the mode in which the file is open.
          Each file object can be connected with a physical file or not.
          Various shell's functions that deal with files shell access
          files through file objects. </p>
        <p>Elements of file variables can be empty (uninitialised) which
          means that they contain no data and that they are not
          connected with any files. <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572497"></a><b><font size="+1">File
                Interpreter's Functions for Manipulating File Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          <ol>
            <li> <a name="_Toc436572498"></a><b><font size="+1">newfile</font><i>
                  { varname &lt; [ dim1, dim2, ... ] &gt; }</i></b></li>
            <br>
            Does the same as <b>newmatrix</b>, but for file variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572499"></a><b><font size="+1">dimfile</font><i><font
                    size="-1"> { varname &lt; [ dim1, dim2, ... ] &gt; }</font></i></b></li>
            <br>
            Does the same as<b>dimmatrix</b>, but for file variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572500"></a><b><font size="+1">setfile</font><i><font
                    size="-1"> { elspec filespec }</font></i></b></li>
            <br>
            Sets a file element specified by <i>elspec</i> to the value
            specified by <i>filespec</i>. The specification of a file
            element <i>elspec</i> consists of a variable name and an
            optional index list in square brackets, e.g. <i>f1[2,3]</i>.
            The index list is not necessary if the rank of the file
            variable is 0.
            <p><i>elspec</i> must address an existing file element,
              except if no indices are specified. In this case a file
              variable of rank 0 is created before the file element is
              set. </p>
            <p><i>filespec</i> specifies the value of the file object.
              It consists of the file name (i.e. the name of the
              physical file) and optional mode in which the file is
              open: </p>
            <p><i>filespec = filename &lt; openmode &gt;</i> </p>
            <p><i>openmode</i> ia a string which defines how the file
              must be open. It consists of one or two letters, with the
              following possibilities: <i>r, w, a, r+, w+, a+</i>
              (Table 1). <br>
              &nbsp; </p>
            <p><b>Table 2</b>: Meaning of different opening modes for
              files. <br>
              &nbsp;
              <table width="519" cellpadding="7" border="">
                <tbody>
                  <tr>
                    <td width="11%" valign="TOP"><b>mode</b></td>
                    <td width="89%" valign="TOP"><b>meaning</b></td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>r</b></td>
                    <td width="89%" valign="TOP">Opens the file for
                      reading. The file must have existed before if we
                      want to open it in this mode. The file position is
                      set to the beginning of the file (i.e. 1).</td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>w</b></td>
                    <td width="89%" valign="TOP">Opens the file for
                      writing. If the file already exists, it is
                      overwritten. If it does not exist, it is created
                      anew.</td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>a</b></td>
                    <td width="89%" valign="TOP">Opens the file for
                      appending. This option is similar to <b>w</b>,
                      except that the old content of the file is not
                      overwritten if it has existed before. The file
                      position is set to the end of the file.</td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>r+</b></td>
                    <td width="89%" valign="TOP">The same as <b>r</b>,
                      except that writing to the file is also possible.</td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>w+</b></td>
                    <td width="89%" valign="TOP">The same as <b>w</b>,
                      except that reading from the file is also
                      possible.</td>
                  </tr>
                  <tr>
                    <td width="11%" valign="TOP"><b>a+</b></td>
                    <td width="89%" valign="TOP">The same as <b>a</b>,
                      except that reading from the file is also
                      possible.</td>
                  </tr>
                </tbody>
              </table>
            </p>
            <p>The <b>setfile</b> function opens the file in the mode
              specified. If the <b>setfile</b> function is repeated
              with the same file object, the file connected to that
              object is closed if it was open before the execution of
              the command and vice versa. <br>
              &nbsp; <br>
              &nbsp; </p>
            <li> <a name="_Toc436572501"></a><b><font size="+1">copyfilevar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>copymatrixvar</b>, but for file
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572502"></a><b><font size="+1">movefilevar</font><i>
                  { varname1 varname2 }</i></b></li>
            <br>
            Does the same as <b>movematrixvar</b>, but for file
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572503"></a><b><font size="+1">deletefilevar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>deletematrixvar</b>, but for file
            variables. The files that are deleted are closed first. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572504"></a><b><font size="+1">printfilevar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for file
            variables. The name of the physical file, the current
            position in the physical file and the opening mode of the
            file are printed for each file element. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572505"></a><b><font size="+1">fprintfilevar</font><i>
                  { varname }</i></b></li>
            <br>
            Does the same as <b>printmatrixvar</b>, but for file
            variables. The name of the physical file, the current
            position in the physical file and the opening mode of the
            file are printed for each file element. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572506"></a><b><font size="+1">copyfile</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>copymatrix</b>, but for file variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572507"></a><b><font size="+1">movefile</font><i>
                  { subspec1 subspec2 }</i></b></li>
            <br>
            Does the same as <b>movematrix</b>, but for file variables.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572508"></a><b><font size="+1">deletefile</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>deletematrix</b>, but for file
            variables. The files that are deleted are closed first. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572509"></a><b><font size="+1">printfile</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>printmatrix</b>, but for file
            variables. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572510"></a><b><font size="+1">fprintfile</font><i>
                  { subspec }</i></b></li>
            <br>
            Does the same as <b>fprintmatrix</b>, but for file
            variables.
          </ol>
          <br>
          &nbsp;
          <li> <a name="_Toc436572511"></a><b><font size="+1">Expression

                Evaluator's Functions for Manipulating File Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol>
          <ol>
            <li> <a name="_Toc436572512"></a><b><font size="+1">getfile</font><i>
                  { varname dataid &lt; elind1, elind2, ... &gt; }</i></b></li>
            <br>
            Returns specific data about a specific file object. <i>varname</i>
            is the name of a file variable. <i>elind1</i>, <i>elind2</i>,
            etc., are the indices which specify the file element on the
            variable's element table. If the variable named <i>varname</i>
            is of rank 0, then no indices <i>elind1</i>, <i>elind2</i>,
            etc. need to be specified.
            <p><i>dataid</i> specifies which data about the file object
              must be returned. According to the value of <i>dataid</i>,
              the function returns the following: <br>
              &nbsp;
              <table width="491" cellpadding="7" border="">
                <tbody>
                  <tr>
                    <td width="12%" valign="TOP"><i>dataid</i></td>
                    <td width="88%" valign="TOP">what is returned by <b>getfile</b></td>
                  </tr>
                  <tr>
                    <td width="12%" valign="TOP">0</td>
                    <td width="88%" valign="TOP">1 if the file is open,
                      0 otherwise.</td>
                  </tr>
                  <tr>
                    <td width="12%" valign="TOP">1</td>
                    <td width="88%" valign="TOP">1 if the file is open
                      for reading, 0 otherwise.</td>
                  </tr>
                  <tr>
                    <td width="12%" valign="TOP">2</td>
                    <td width="88%" valign="TOP">1 if the file is open
                      for writing, 0 otherwise.</td>
                  </tr>
                  <tr>
                    <td width="12%" valign="TOP">3</td>
                    <td width="88%" valign="TOP">The current position of
                      the file; positions start with 1 and mean the
                      positions in the file in bytes where the
                      operations act.</td>
                  </tr>
                </tbody>
              </table>
              <br>
              &nbsp; </p>
            <li> <a name="_Toc436572513"></a><b><font size="+1">getfiledim</font><i>
                  { varname dimnum }</i></b></li>
            <br>
            The same as <b>getmatrixdim</b>, but for file variables.
          </ol>
        </ol>
        <br>
        &nbsp; <br>
        &nbsp;
        <li> <a name="_Toc436572514"></a><b><i><font size="+2">Shell's
                Variables with a Pre-defined Meaning</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Some variables of the shell have a pre-defined meaning and
          are supposed to be used for a particular purpose. They are
          basically still user-defined variables and behave in many
          terms the same as other user-defined variables. They are
          distinguished in a sense that they are used to accomplish
          specific tasks. Besides, some operations that act on variables
          of specific types treat the pre-defined variables in a
          slightly different way, usually with some additional
          automatism. </p>
        <p>Each pre-defined variable serves for specific tasks. Some of
          them store results of operations and algorithms without this
          should be specified by the user. These results are
          automatically available for further use after the appropriate
          operations are finished. The others serve for data exchange
          between different shell's functions, e.g. between optimisation
          algorithms and the function, which performs the direct
          analysis. Both kinds of variables are supposed to carry the
          information with exactly defined meaning, e.g. the current
          value of the objective function or the optimised values of
          parameters. Furtherly, we can find yet another group of
          pre-defined variables. These simply serve as variables on
          which certain operations act without the variable in use is
          explicitly specified. A typical example is the shell's output
          file (variable <i>outfile</i>) to which the output of the
          function <b>fwrite</b> (and many others) is directed,
          although this is never explicitly specified. </p>
        <p>There is usually some additional automatism connected with
          the pre-defined variables. For example, when a pre-defined
          file <i>outfile</i> is open by the <b>setfile</b> function,
          the file is open for writing without this is explicitly
          specified in the argument block of the <b>setfile</b>
          command. When a pre-defined vector or matrix variable is set
          by the <b>setvector</b> or <b>setmatrix</b> command, it is
          not necessary to specify the variable dimensions if the
          dimensions are known from what was done in the shell before. </p>
        <p>To generalise the above statements, we can establish that
          there is usually some information related with the pre-defined
          variables which has more general meaning. Such information is
          for example the number of optimisation parameters. Dimensions
          of several pre-defined vector, matrix and scalar variables are
          bound to the number of parameter. Once the number of
          parameters is known to the shell, the appropriate dimensions
          of pre-defined variables that are bound to this information
          are also known and they need not to be specified in some
          functions which operate on variables. </p>
        <p>Such general information as the number of parameters are
          stored in theshell in special places separatedfrom the system
          of user-defined variables. These information either exist in
          advance (e.g. the information that the pre-defined file <i>outfile</i>
          should normally be open for writing) or are set when some
          related actions are undertaken. For example, the number of
          parameteers is set when the appropriate dimension of any
          pre-defined variable related to this information is set (e.g.
          the dimension of the vector <i>parammom</i> or <i>paramopt</i>).
          The user can access (i.e. set and get) these information in
          two ways: through the dependent information about variables
          and through the appropriate expression evaluator's and file
          interpreter's functions. <br>
          &nbsp; <br>
          &nbsp; <br>
          &nbsp; </p>
        <ol>
          <li> <a name="_Toc436572515"></a><b><font size="+1">Pre-defined

                Matrix, Vector and Scalar Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="2">
          Matrix, vector and scalar pre-defined variables hold general
          information which is directly related to optimisation or
          inverse problems, like the initial, current and optimal values
          of parameters, experimental measurements and their errors,
          simulated measurements, the objective function and the
          constraint functions and their derivatives with respect to
          parameters,etc. It is obvious that groups of these variables
          are related through their dimensions. For example, the vector
          of (curtrent) parameters has the same dimension as the
          gradient of the objective function.
          <p>General information related to these pre-defined variables
            are listed in Table 3. These information are not stored in
            the user-defined variables, but in the internal shel's
            variables. They can be obtained and set through special
            expression evaluator's and file interpreter's functions. </p>
          <p><a name="_Ref434852142"></a><b>Table 3</b>: general
            information related to some pre-defined matrix, vector, and
            scalar variables: <br>
            &nbsp;
            <table width="567" cellpadding="7" border="">
              <tbody>
                <tr>
                  <td width="23%" valign="TOP"><b>information</b></td>
                  <td width="77%" valign="TOP"><b>meaning</b></td>
                </tr>
                <tr>
                  <td width="23%" valign="TOP"><i>numparam</i></td>
                  <td width="77%" valign="TOP">The number of
                    optimisation parameters</td>
                </tr>
                <tr>
                  <td width="23%" valign="TOP"><i>numconstraints</i></td>
                  <td width="77%" valign="TOP">The number of constraint
                    functions</td>
                </tr>
                <tr>
                  <td width="23%" valign="TOP"><i>numobjectives</i></td>
                  <td width="77%" valign="TOP">The number of the
                    objective functions (usually equals 1)</td>
                </tr>
                <tr>
                  <td width="23%" valign="TOP"><i>nummeas</i></td>
                  <td width="77%" valign="TOP">The number of
                    measurements (applicable for inverse problems)</td>
                </tr>
              </tbody>
            </table>
          </p>
          <p>Some automatism is built in the shell regarding the
            pre-defined matrix, vector and scalar variable. This
            especially concerns the file interpreter's functions that
            assign values to variable elements or allocate variables.
            When a specific dimensions of any of these pre-defined
            variables or their elements is set, the appropriate internal
            shell's variable related to that dimension changes
            accordingly. </p>
          <p>The oposite is also valid: When we call functions that set
            the values of variable elements, we do not need to specify
            dimensions that are determined by the shell's internal
            variables that have defined values. </p>
          <p><b>Example:</b> </p>
          <p>Let's say that we set the vector of initial guesses <i>param0</i>
            with dimension 3: </p>
          <p><b><font size="+0">setvector</font><i> {param0 3 { 2.43
                5.34 6.444 }}</i></b> </p>
          <p>Since this pre-defined vector has by definition the
            dimension <i>numparam</i>, the shell's internal variable <i>numparam</i>
            is automatically set to 3. The same effect would have, for
            example, the code </p>
          <p><b><font size="+0">setvector</font><i> {paramopt 3 }</i></b>
          </p>
          <p>since the pre-defined vector <i>paramopt</i> has by
            definition the same dimension (<i>numparam</i>). </p>
          <p>If we then set the vector of current parameter values <i>parammom</i>,
            we do not need to specify its dimension, although the vector
            variable does not yet exist and will be created anew. This
            is because the dimension of this vector, which is by
            definition <i>numparam</i>, is already known since it was
            set implicitly when the dimension of the vector <i>param0</i>
            or <i>paramopt</i> was set. Therefore, we can set the
            vector <i>parammom</i> simply by specifying components: </p>
          <p><b><font size="+0">setvector</font><i> {parammom { 1.64
                22.3 101.1 }}</i></b> <br>
            &nbsp; <br>
            &nbsp; </p>
          <ol>
            <li> <a name="_Toc436572516"></a><b><font size="+1">Scalar
                  Pre-defined Variables</font></b></li>
            <br>
            &nbsp;
            <table width="567" cellpadding="7" border="">
              <tbody>
                <tr>
                  <td width="47%" valign="TOP"><b>pre-defined scalar
                      variable</b></td>
                  <td width="53%" valign="TOP"><b>characterisation of
                      the variable</b></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">objectivemom

                        [] &lt; [numobjectives] &gt;</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Value(s)
                      of the objective function(s) at the current
                      parameter values.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">objectiveopt

                        [] &lt; [numobjectives] &gt;</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Value(s)
                      of the objective function(s) at the optimal values
                      of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">objective0

                        [] &lt; [numobjectives] &gt;</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Value(s)
                      of the objective function(s) at the initial guess.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">constraintmom

                        [numconstraints]</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Values of
                      the constraint functions at the current values of
                      parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">constraintopt

                        [numconstraints]</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Values of
                      the constraint functions at the optimal values of
                      parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">constraint0

                        [numconstraints]</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Values of
                      the constraint functions at the initial guess.</font></td>
                </tr>
              </tbody>
            </table>
            <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572517"></a><b><font size="+1">Vector
                  Pre-defined Variables</font></b></li>
            <br>
            &nbsp;
            <table width="567" cellpadding="7" border="">
              <tbody>
                <tr>
                  <td width="47%" valign="TOP"><b>pre-defined vector
                      variable</b></td>
                  <td width="53%" valign="TOP"><b>characterisation of
                      the variable</b></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">parammom

                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Current
                      vaules of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">paramopt

                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Optimal
                      values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">param0
                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Initial
                      guess for parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">parammomold

                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">A copy of
                      current parameter values (usually made when the
                      current parameters are transformed).</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">transf
                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Vector of
                      transformed parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">direction

                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Directin
                      of a line search.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">startpoint

                        [] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Initial
                      point of the line search.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">meas
                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Experimental

                      measurements (used at inverse analyses)</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">sigma
                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Vector of
                      measurement errors.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">measexact

                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Exact
                      measurements; Imaginary quantity that is used e.g.
                      at monte carlo simulations with aim to estimate
                      the influence of the measurement errors on the
                      results.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">measmom

                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Current
                      values of simulated measurements.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">measopt

                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Simulated
                      measurements in the optimum (i.e. solution of the
                      inverse problem).</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">meas0
                        [] (nummeas)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Simulated
                      measurements at the starting guess (i.i. <i>param0</i>).</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradobjectivemom

                        [] &lt;[numobjectives]&gt; (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradient
                      of the objective function(s) at the current
                      parameter vlues.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradobjectiveopt

                        [] &lt;[numobjectives]&gt; (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradient
                      of the objective function(s) at the optimum.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradobjective0

                        [] &lt;[numobjectives]&gt; (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradient
                      of the objective function(s) at the initial guess.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradconstraintmom

                        [numconstraints] (numparm)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the constraint functions at the current
                      parameter values.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradconstraintopt

                        [numconstraints] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the constraint functions at the optimal values
                      of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradconstraint0

                        [numconstraints] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the constraint functions at the initial guess.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradmeasmom

                        [nummeas] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the simulated measurements at the current
                      values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradmeasopt

                        [nummeas] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the simulated measurements at the optimum.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">gradmeas0

                        [nummeas] (numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Gradients
                      of the simulated measurements at the initial
                      guess.</font></td>
                </tr>
              </tbody>
            </table>
            <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572518"></a><b><font size="+1">Matrix
                  Pre-defined Variables</font></b></li>
          </ol>
          <ol start="2">
            &nbsp;
            <table width="567" cellpadding="7" border="">
              <tbody>
                <tr nosave="">
                  <td nosave="" width="47%" valign="TOP"><b>pre-defined
                      matrix variable</b></td>
                  <td width="53%" valign="TOP"><b>characterisation of
                      the variable</b></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2objectivemom

                        [] &lt; [numobjectives] &gt; (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the objective function(s)
                      at the current values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2objectiveopt[]

                        &lt; [numobjectives] &gt; (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the objective function(s)
                      at the optimal values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2objective0[]

                        &lt; [numobjectives] &gt; (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the objective function(s)
                      at the initial guess.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2constraintmom

                        [numconstraints] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the constraint functions
                      at the current values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2constraintopt

                        [numconstraints] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the constraint functions
                      at the optimal values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2constraint0

                        [numconstraints] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the constraint functions
                      at the initial guess.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2measmom

                        [nummeas] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the simulated
                      measurements at the current values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2measopt

                        [nummeas] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the simulated
                      measurements at the optimal values of parameters.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">der2meas0

                        [nummeas] (numparam,numparam)</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Second
                      derivatives (Hessian) of the simulated
                      measurements at the initial guess.</font></td>
                </tr>
              </tbody>
            </table>
          </ol>
          <br>
          &nbsp;
          <li> <a name="_Toc436572519"></a><b><font size="+1">File
                Interpreter's Functions for Setting Shell's Internal
                Data Related to Pre-defined Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="3">
          <ol>
            <li> <a name="_Toc436572520"></a><b><font size="+1">setnumparam</font><i>
                  { val }</i></b></li>
            <br>
            Sets the number of parameters <i>numparam</i> to <i>val</i>.
            Val is a numerical argument, which means that it can be
            given as a number, as a mathematical expression in the form
            <i>${expr}</i> or as an expression evaluator's variable in
            the form <i>$varname</i>. If a non-integer value is given
            for <i>val</i>, it is rounded. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572521"></a><b><font size="+1">setnumobjectives</font><i>
                  { val }</i></b></li>
            <br>
            Sets the number of objective functions <i>numobjective</i>
            to <i>val</i>. By default, this number is set to 1. Val is
            a numerical argument, which means that it can be given as a
            number, as a mathematical expression in the form <i>${expr}</i>
            or as an expression evaluator's variable in the form <i>$varname</i>.
            If a non-integer value is given for <i>val</i>, it is
            rounded. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572522"></a><b><font size="+1">setnumconstraints</font><i>
                  { val }</i></b></li>
            <br>
            Sets the number of constraint functions <i>numconstraints</i>
            to <i>val</i>. Val is a numerical argument, which means
            that it can be given as a number, as a mathematical
            expression in the form <i>${expr}</i> or as an expression
            evaluator's variable in the form <i>$varname</i>. If a
            non-integer value is given for <i>val</i>, it is rounded. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572523"></a><b><font size="+1">setnummeas</font><i>
                  { val }</i></b></li>
            <br>
            Sets the number of measurements <i>nummeas</i> to <i>val</i>.
            Val is a numerical argument, which means that it can be
            given as a number, as a mathematical expression in the form
            <i>${expr}</i> or as an expression evaluator's variable in
            the form <i>$varname</i>. If a non-integer value is given
            for <i>val</i>, it is rounded.
          </ol>
          <li> <a name="_Toc436572524"></a><b><font size="+1">Expression

                Evaluator's Functions for Accessing Shell's Internal
                Data Related to Pre-defined Variables</font></b></li>
        </ol>
        <br>
        &nbsp;
        <ol start="4">
          <ol>
            <li> <a name="_Toc436572525"></a><b><font size="+1">getnumparam</font><i>
                  [ ]</i></b></li>
            <br>
            Returns the number of parameters <i>numparam</i>. <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572526"></a><b><font size="+1">getnumobjectives</font><i>[
                  ]</i></b></li>
            <br>
            Returns the number of objective functions <i>numobjectives</i>.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572527"></a><b><font size="+1">getnumconstraints</font><i>
                  [ ]</i></b></li>
            <br>
            Returns the number of constraint functions <i>numconstraints</i>.
            <br>
            &nbsp; <br>
            &nbsp;
            <li> <a name="_Toc436572528"></a><b><font size="+1">getnummeas</font><i>
                  [ ]</i></b></li>
            <br>
            Returns the number of measurements <i>nummeas</i>.
          </ol>
          <li> <a name="_Toc436572529"></a><b><font size="+1">Pre-defined

                File Variables</font></b></li>
          <br>
          &nbsp;
          <p>&nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp; </p>
          <p>The pre-defined file variables represent files which have a
            specific meaning in the shell, e.g. the shell's output file
            or the input and output file of the direct analysis. Some
            operations act exclusively in these pre-defined files. For
            example, the <b>fwrite</b> function prints its output to a
            pre-defined file <i>outfile</i>. </p>
          <p>The pre-defined file variables should have rank 0, although
            this is not always necessary. However, in all cases only the
            first element of the file variable's element table can be
            involved in operations that act on pre-defined files. The
            user should avoid defining pre-defined variables with rank
            greater than zero. <br>
            &nbsp; <br>
            &nbsp; </p>
          <ol>
            <li> <a name="_Toc436572530"></a><b><font size="+1">File
                  Pre-defined Variables</font></b></li>
          </ol>
        </ol>
      </ol>
    </ol>
    <blockquote>
      <blockquote>
        <blockquote>
          <blockquote>&nbsp;
            <table width="567" cellpadding="7" border="">
              <tbody>
                <tr>
                  <td width="47%" valign="TOP"><b>pre-defined file
                      variable</b></td>
                  <td width="53%" valign="TOP"><b>characterisation of
                      the variable</b></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">infile
                        []</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Shell-s
                      input file.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">outfile

                        []</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">Shell-s
                      output file.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">aninfile

                        []</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">The
                      simulation (direct analysis) input file.</font></td>
                </tr>
                <tr>
                  <td width="47%" valign="TOP"><b><font size="-1">anoutfile

                        []</font></b></td>
                  <td width="53%" valign="TOP"><font size="-1">The
                      simulation (direct analysis) output file.</font></td>
                </tr>
              </tbody>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
    </blockquote>
  </body>
</html>
