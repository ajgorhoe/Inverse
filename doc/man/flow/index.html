<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;
      charset=windows-1252">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="GENERATOR" content="Mozilla/4.5 [en] (X11; I; HP-UX
      B.10.20 9000/780) [Netscape]">
    <title>Inverse manual: Programme Flow Control in the Optimisation
      Shell INVERSE</title>
    <!-- Google Analitics - account Documents, 
	property Documents - all -->
    <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-96832295-1', 'auto');
	  ga('send', 'pageview');
	</script>
    <meta name="author" content="Igor Grešovnik">
    <meta name="description" content="Inverse manual: Programme Flow
      Control in the Optimisation Shell INVERSE">
  </head>
  <body vlink="#551A8B" text="#000000" link="#0000EE" bgcolor="#FFFFFF"
    alink="#FE0000">
    <a href="../../../invhome.html"><img src="../../../invlogo.gif"
        nosave="" moz-do-not-send="true" title="Inverse Home"
        alt="Inverse logo" width="600" height="100" border="0"></a> <br>
    &nbsp; <br>
    &nbsp;
    <table nosave="" border="3" bgcolor="#99FFCC">
      <tbody>
        <tr nosave="">
          <td nosave=""><a name="list"></a><font size="-1"><a
                href="../index.html">MANUALS:</a></font>
            <blockquote>
              <li> <font size="-1"><a href="../short/index.html">Short
                    Guide to INVERSE</a></font></li>
              <li> <b><font size="-1"><a href="index.html">Flow Control</a></font></b></li>
              <blockquote>
                <li> <b><font size="-1"><a href="#_Toc442156980">The
                        shell's File Interpreter</a></font></b></li>
                <li> <b><font size="-1"><a href="#_Toc442156994">Branches

                        and Loops</a></font></b></li>
                <li> <b><font size="-1"><a href="#_Toc442157005">Definition

                        of New File interpreter's functions&nbsp;</a></font></b></li>
              </blockquote>
              <li> <font size="-1"><a href="../calc/index.html">Expression

                    evaluator</a></font></li>
              <li> <font size="-1"><a href="../var/index.html">User
                    defined variables</a></font></li>
              <li> <font size="-1"><a href="../int/index.html">General
                    file interface</a></font></li>
              <li> <font size="-1"><a href="../debug/index.html">Syntax
                    checker &amp; debugger</a></font></li>
              <li> <font size="-1"><a href="../sim/index.html">Interfaces

                    with simulation programmes</a></font></li>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
      <tbody>
        <tr nosave="" valign="TOP">
          <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
          <td nosave=""><b><font size="-1"><a
                  href="../manlist/index.html#list">Manuals list &amp;
                  contents</a></font></b></td>
          <td nosave=""><b><font size="-1"><a href="#contents">Table of
                  contents&nbsp;</a></font></b></td>
        </tr>
      </tbody>
    </table>
    <br>
    &nbsp; <br>
    &nbsp; <br>
    &nbsp;
    <center>
      <p><b><i><font size="+2">Programme Flow Control in the</font></i></b>
      </p>
      <p><b><i><font size="+2">Optimisation Shell INVERSE</font></i></b>
        <br>
        &nbsp; <br>
        &nbsp; </p>
      <p><b><font size="+1">Version 0</font></b> <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; <br>
        &nbsp; </p>
      <p><i>Igor Gresovnik</i> <br>
        &nbsp; <br>
        &nbsp; </p>
      <p><i><font size="-1">Ljubljana, the 30<sup> th</sup> of November
            1998</font></i></p>
    </center>
    <p><br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
    </p>
    <p><a name="contents"></a><b><font color="#FF0000"><font size="+1">Table
of

            contents:</font></font></b> <br>
      &nbsp; </p>
    <p><b><font size="-1">1. Flow control </font></b><a
        href="#_Toc442156979">*</a> </p>
    <dir><font size="-1">1.1 The Shell's File Interpreter </font><a
        href="#_Toc442156980">*</a>
      <dir>&nbsp; <br>
        <i><font size="-1">1.1.1 File Interpreter's Syntax </font></i><a
          href="#_Toc442156981">*</a>
        <p><i><font size="-1">1.1.2 Argument Passing </font></i><a
            href="#_Toc442156982">*</a> <br>
          &nbsp; </p>
        <dir><font size="-2">1.1.2.1 General Rules </font><a
            href="#_Toc442156983">*</a>
          <p><font size="-2">1.1.2.2 Numerical Arguments </font><a
              href="#_Toc442156984">*</a> </p>
          <p><font size="-2">1.1.2.3 Mathematical Expressions as
              Arguments </font><a href="#_Toc442156985">*</a> </p>
          <p><font size="-2">1.1.2.4 String Arguments </font><a
              href="#_Toc442156986">*</a> </p>
          <p><font size="-2">1.1.2.5 Specifications of User-defined
              Variables, Variable Elements and Sub-tables of Variable
              Elements </font><a href="#_Toc442156987">*</a> </p>
          <p><font size="-2">1.1.2.6 Objects of Various Types </font><a
              href="#_Toc442156988">*</a></p>
        </dir>
        <p><br>
          &nbsp; <i><font size="-1">1.1.3 Functions for Input and
              Output </font></i><a href="#_Toc442156989">*</a> <br>
          &nbsp; </p>
        <dir><font size="-2">1.1.3.1 write<i> { arg1 arg2 ... }</i> </font><a
            href="#_Toc442156990">*</a>
          <p><font size="-2">1.1.3.2 fwrite<i> { arg1 arg2 ... }</i> </font><a
              href="#_Toc442156991">*</a> </p>
          <p><font size="-2">1.1.3.3 dwrite<i> { arg1 arg2 ... }</i> </font><a
              href="#_Toc442156992">*</a> </p>
          <p><font size="-2">1.1.3.4 read<i> { varname }</i> </font><a
              href="#_Toc442156993">*</a></p>
        </dir>
      </dir>
      <p><br>
        <font size="-1">1.2 Branches and Loops </font><a
          href="#_Toc442156994">*</a> </p>
      <dir>&nbsp; <br>
        <i><font size="-1">1.2.1 Branching, Looping and Other Flow
            Control Functions </font></i><a href="#_Toc442156995">*</a>
        <br>
        &nbsp;
        <dir><font size="-2">1.2.1.1 if <i>{ ( condition ) [ block1 ]
              &lt; &lt; else &gt; [ block2 ] &gt; }</i> </font><a
            href="#_Toc442156996">*</a>
          <p><font size="-2">1.2.1.2 while<i> { ( condition ) [ block ]
                }</i> </font><a href="#_Toc442156997">*</a> </p>
          <p><font size="-2">1.2.1.3 do<i> { [ block ] &lt; while &gt;
                (condition) }</i></font><a href="#_Toc442156998">*</a> </p>
          <p><font size="-2">1.2.1.4 interpret<i> { filename }</i> </font><a
              href="#_Toc442156999">*</a> </p>
          <p><font size="-2">1.2.1.5 exit<i> { &lt; numlev &gt; }</i> </font><a
              href="#_Toc442157000">*</a> </p>
          <p><font size="-2">1.2.1.6 block<i> { blockcode }</i> </font><a
              href="#_Toc442157001">*</a> </p>
          <p><font size="-2">1.2.1.7 goto<i> { labelname }</i> </font><a
              href="#_Toc442157002">*</a> </p>
          <p><font size="-2">1.2.1.8 label<i> { labelname }</i> </font><a
              href="#_Toc442157003">*</a> </p>
          <p><font size="-2">1.2.1.9 comment<i> { comments }</i>, *<i> {
                comments }</i></font><a href="#_Toc442157004">*</a></p>
        </dir>
      </dir>
      <p><br>
        &nbsp; <font size="-1">1.3 Definition of New File Interpreter's
          Functions </font><a href="#_Toc442157005">*</a> <br>
        &nbsp; </p>
      <dir>
        <dir><font size="-2">1.3.1.1 function<i> { funcname ( arglist )
              [ defblock ] }</i> </font><a href="#_Toc442157006">*</a>
          <p><font size="-2">1.3.1.2 update<i> { code }</i> </font><a
              href="#_Toc442157007">*</a> </p>
          <p><font size="-2">1.3.1.3 numfuncargs<i> [ ]</i> </font><a
              href="#_Toc442157008">*</a></p>
        </dir>
      </dir>
      <br>
      &nbsp;
      <ol>
        <center><a name="_Toc442156979"></a></center>
      </ol>
    </dir>
    <ol>
      <ol>
        &nbsp;
      </ol>
      <li> <b><font size="+2">Flow control</font></b></li>
      <br>
      &nbsp;
      <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
        <tbody>
          <tr nosave="" valign="TOP">
            <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
            <td nosave=""><b><font size="-1"><a
                    href="../manlist/index.html#list">Manuals list &amp;
                    contents</a></font></b></td>
            <td nosave=""><b><font size="-1"><a href="#contents">Table
                    of contents&nbsp;</a></font></b></td>
          </tr>
        </tbody>
      </table>
      <p>When the optimisation shell <i>INVERSE</i> is run, the command
        file interpretation is triggered immediately after the
        initialisation. Everything what happens in the shell from that
        point on is a consequence of the file interpreter's functions
        (commands) called in the command file. </p>
      <ol>
        &nbsp;
      </ol>
      Beside the functions, which perform shell's built-in algorithms
      and utilities, there are also flow control functions which make
      possible programming the command file in a similar way as
      programming with a high level programming language. This feature
      of the shell is additionally supported by concepts of user-defined
      variables and the expression evaluator. By the flow control, user
      can write portions of code which are executed several times
      dependent on specified conditions. The conditions can depend on
      anything what determines the current state in the shell, which
      includes the results of algorithms and operations which have
      already been performed.
      <p>The branching and looping functions execute specific portions
        (blocks) of code if certain conditions are true. The blocks of
        code and conditions must be given in the argument blocks of
        these functions. Such functions can be nested to an arbitrary
        depth. </p>
      <p>New interpreter's functions can be defined by the file
        interpreter commands. Their definition block of code is executed
        simply by calling the newly defined function. </p>
      <ol>
        &nbsp;
        <ol>
          &nbsp;
          <center>
            <p><a name="_Toc442156980"></a></p>
          </center>
        </ol>
        <li> <b><i><font size="+2">The Shell's File Interpreter</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <ol>
          &nbsp; <br>
          &nbsp;
          <ol>
            <a name="_Toc442156981"></a>
          </ol>
          <li> <b><font size="+1">File Interpreter's Syntax</font></b></li>
          <ol>
            &nbsp;
          </ol>
          The syntax of the file interpreter is as simple as possible.
          The interpreted file consists of function calls (commands),
          which follow each other. Function calls consist of the
          function name and function argument block in curly brackets.
          Basically, the syntax of the shell's interpreter is the
          following:
          <p><i><font size="+0">funcname1 {argblock1} funcname2
                {argblock2} funcname3{argblock3} ...</font></i> </p>
          <p>When the interpreter encounters a call to a function, it
            executes the corresponding shell's internal function
            associated with that interpreter's function. The interpreter
            does not pass the arguments from the argument block of the
            function call to this internal function. It only passes the
            information about where the argument block of the function
            can be found (i.e. the file and the position). The
            associated internal function of the shell extracts arguments
            from the argument block interpreting their meaning at the
            same time, and does what it is supposed to do. </p>
          <p>Some functions associated with the file interpreter
            functions are able to call the file interpreter to interpret
            specific blocks of code, usually parts of the argument
            blocks of the corresponding file interpreter's functions.
            The flow control is implemented by such functions. <br>
            &nbsp; </p>
          <ol>
            <a name="_Toc442156982"></a> <br>
            &nbsp;
          </ol>
          <li> <b><font size="+1">Argument Passing</font></b></li>
          <ol>
            &nbsp;
          </ol>
          Most of the file interpreter's functions require arguments. On
          these arguments it depends what these functions do and how
          they do it.
          <p>Function arguments appear in curly brackets which follow
            the function name in the interpreted file. Every function
            call must have these curly brackets, but the brackets may be
            empty. </p>
          <p>The space inside the curly brackets that follow the
            function name is called argument block of the function.
            Function arguments can be specified in this block. The file
            interpreter does not pass arguments to the shell's functions
            that are associated with the interpreter's functions.
            Instead, it passes the information about where the
            function's argument block is placed. The associated function
            itself must extract its arguments from the argument block.
            Therefore the complete freedom of interpreting arguments is
            left to the associated functions. The file interpreter does
            not impose any rules about how arguments should be
            interpreted. </p>
          <p>Such freedom allows setting rules for argument formats
            which best suit the meaning and aim of arguments. On the
            other hand, this freedom allows for every function to
            require its own format of arguments. Therefore, some rules
            are imposed about the formats of arguments that are required
            by the file interpreter's functions. An overview of these
            rules is given below. </p>
          <ol>
            <ol>
              &nbsp;
              <p><a name="_Toc442156983"></a></p>
            </ol>
            <li> <b><font size="+1">General Rules</font></b></li>
            <ol>
              &nbsp;
            </ol>
            At functions with several arguments these are usually
            separated by spaces. Because some arguments (respectively
            strings which represent them) can themselves contain spaces,
            it must be unambiguous for each type of argument from where
            to where it extends. This is the basic requirements for
            formatting conventions. Let us show some examples how this
            requirement is took into account.
            <p>Strings must be in double quotes and may not explicitly
              contain the double quote characters. All double quotes
              within string arguments must be replaced by the
              appropriate sequences (<i>\d</i>). </p>
            <p>Mathematical expressions are usually contained in
              brackets. Because all brackets in expression must be
              closed, the brackets which contain an expression can not
              be mixed up with brackets which eventually appear within
              the expression. </p>
            <p>Specifications of variable's elements consist of variable
              name and an optional index list in square brackets.
              Variable name extends either until the first space or
              until the first square bracket. If a square bracket is
              encountered after the variable name, it is clear that an
              index list is specified and the argument extends till the
              closed square bracket. Otherwise there is no index list
              and the argument extends till the last character of the
              name. </p>
            <ol>
              &nbsp;
              <p><a name="_Toc442156984"></a></p>
            </ol>
            <li> <b><font size="+1">Numerical Arguments</font></b></li>
            <p><br>
              Numerical arguments can be given in different ways. The
              most elementary way is to specify them as numbers, e.g. <i>124</i>,
              <i>-3.64567</i>, <i>6.02e23</i>. Numbers can be written
              in a standard format used in most programming languages. </p>
            <p>We can specify mathematical expressions or expression
              evaluator's variables in place of numbers. Numerical
              arguments can be specified by mathematical expressions in
              the form </p>
            <p><i>${expr}</i> </p>
            <p>where <i>expr</i> is the expression which can be
              evaluated by the expression evaluator. The expression does
              not need to be in double quotes. Spaces are allowed
              between the $ sign and the bracket. </p>
            <p>The specification of numerical arguments by the
              expression evaluator's variables has the form </p>
            <p><i>$varname</i> </p>
            <p>where <i>varname</i> is the name of the calculator's
              variable. </p>
            <p>Where numerical arguments are replaced by mathematical
              expressions or calculator's variables, these are first
              evaluated in the expression evaluator and the obtained
              values are used as arguments. The functions associated
              with the file interpreter's commands take care of that. </p>
            <p>Some examples of numerical arguments specified by
              mathematical expressions or calculator's variables: </p>
            <p><i>${3*a+b^3} $a1 $ { getmatrix["Mat2",2,3] }</i> <br>
              &nbsp; <br>
              &nbsp; <br>
              &nbsp; </p>
            <p><a name="_Toc442156985"></a> </p>
            <li> <b><font size="+1">Mathematical Expressions as
                  Arguments</font></b></li>
            <p><br>
              Some arguments are supposed to be mathematical
              expressions. Branching and looping conditions of flow
              control commands are an example of that. In this case, the
              expressions are not contained in curly brackets that
              follow the <i>$</i> sign. Numbers can be specified in
              place of these arguments, but are treated as mathematical
              expressions and are evaluated in the expression evaluator
              (although there is no need to do that). </p>
            <p>When expressions are not the only arguments of a
              function, they must be somehow separated from other
              arguments. Usually they are contained in brackets (e.g.
              conditions in flow control commands). This is because
              expressions can contain spaces and commas which are
              usually used to separate arguments. </p>
            <p>There is a simple intuitive rule about when numerical
              arguments and when expression arguments are used.
              Expression arguments are used if the appropriate arguments
              can be just numbers only in exceptional cases. This is for
              example in flow control conditions or in functions like <b>setmatrixcomponents</b>.
              <br>
              &nbsp; <br>
              &nbsp; </p>
            <p><a name="_Toc442156986"></a> <br>
              &nbsp; </p>
            <li> <b><font size="+1">String Arguments</font></b></li>
            <p><br>
              String arguments are seldomly used in the file
              interpreter's functions. An example of their use is in
              functions like <b>write</b> and in the <b>execute</b> (<b>system</b>)
              function. </p>
            <p>Because string arguments can contain spaces and commas,
              they must be in double quotes. An exception is (currently)
              the <b>execute</b> (<b>system</b>) command, which takes
              only one argument and simply takes the whole argument
              block as string arguments. </p>
            <p>String arguments can contain special characters which can
              not be written in interpreted ASCII files. This problem is
              overcome with two character sequences which represent
              these characters. The sequences are replaced by the
              appropriate special characters if they appear in string
              arguments. The first character of all such sequences is
              '\'. Sequences are the folowing: <br>
              &nbsp; <br>
              &nbsp; </p>
            <p><a name="_Ref436040603"></a><b>Table 1</b>: special
              character sequences. <br>
              &nbsp;
              <table width="697" cellpadding="9" border="">
                <tbody>
                  <tr>
                    <td width="15%" valign="TOP"><b>sequence</b></td>
                    <td width="36%" valign="TOP"><b>meaning</b></td>
                    <td width="15%" valign="TOP"><b>sequence</b></td>
                    <td width="34%" valign="TOP"><b>meaning</b></td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\q</center>
                    </td>
                    <td width="36%" valign="TOP">single quote (')</td>
                    <td width="15%" valign="TOP">
                      <center>\1</center>
                    </td>
                    <td width="34%" valign="TOP">(</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\Q or \d</center>
                    </td>
                    <td width="36%" valign="TOP">double quote (")</td>
                    <td width="15%" valign="TOP">
                      <center>\2</center>
                    </td>
                    <td width="34%" valign="TOP">)</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\\</center>
                    </td>
                    <td width="36%" valign="TOP">backslash (\)</td>
                    <td width="15%" valign="TOP">
                      <center>\3</center>
                    </td>
                    <td width="34%" valign="TOP">[</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\0</center>
                    </td>
                    <td width="36%" valign="TOP">null character</td>
                    <td width="15%" valign="TOP">
                      <center>\4</center>
                    </td>
                    <td width="34%" valign="TOP">]</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\n</center>
                    </td>
                    <td width="36%" valign="TOP">newline character</td>
                    <td width="15%" valign="TOP">
                      <center>\5</center>
                    </td>
                    <td width="34%" valign="TOP">{</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\r</center>
                    </td>
                    <td width="36%" valign="TOP">carriage return</td>
                    <td width="15%" valign="TOP">
                      <center>\6</center>
                    </td>
                    <td width="34%" valign="TOP">}</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">
                      <center>\t</center>
                    </td>
                    <td width="36%" valign="TOP">tab</td>
                    <td width="15%" valign="TOP">
                      <center>\&lt;</center>
                    </td>
                    <td width="34%" valign="TOP">{</td>
                  </tr>
                  <tr>
                    <td width="15%" valign="TOP">&nbsp;</td>
                    <td width="36%" valign="TOP">&nbsp;</td>
                    <td width="15%" valign="TOP">
                      <center>\&gt;</center>
                    </td>
                    <td width="34%" valign="TOP">}</td>
                  </tr>
                </tbody>
              </table>
            </p>
            <ol>
              &nbsp;
            </ol>
            <a name="_Toc442156987"></a>
            <li> <b><font size="+1">Specifications of User-defined
                  Variables, Variable Elements and Sub-tables of
                  Variable Elements</font></b></li>
            <p><br>
              Some functions take arguments that are specifications of
              user-defined variables (e.g. <b>movematrixvar</b>),
              variable elements or sub-tables of variable elements (e.g.
              <b>copymatrix</b>). We must make difference between
              arguments that are specifications of variable elements of
              a specific type and arguments that are objects of a
              specific type (later are described in the following
              chapter). </p>
            <p>Variables are specified simply by a variable name. For
              example, we refer to a matrix variable <i>m1</i> like
              this: </p>
            <p><i>m1</i> </p>
            <p>Variables can hold whole tables of objects of a specific
              type. When we refer to an individual element of such
              variable, we must specify indices of that element. Indices
              must be listed in square brackets which follow the
              variable name and be separated by spaces or commas. There
              can be spaces between the name and square brackets.
              Indices in the index list can be replaced by mathematical
              expressions or variables of the expression evaluator
              according to standard rules. The following specifications
              of variable element are valid and refer to the same
              element if the value of the expression evaluator's
              variable <i>i1</i> is 2: </p>
            <p><i>v [2,3, 2]</i> </p>
            <p><i>v[${4-2} 3 2}]</i> </p>
            <p><i>v[$i1 ${i1+1}, ${2*i1-2}]</i> </p>
            <p>There must be as many indices in the index list as is the
              number of dimensions (i.e. rank) of the appropriate
              variable. If we refer to an element of a variable that has
              rank zero, the indices are not specified. We can simply
              specify variable name or eventually put empty square
              brackets after the name: </p>
            <p><i>a1</i> </p>
            <p><i>a1[ ]</i> </p>
            <p>We refer to sub-tables of variable elements in a similar
              way than to individual elements. The only difference is
              that the number of indices specified in the index list
              does not necessarily equal the number of dimensions of the
              appropriate variable. The specified indices refer by turns
              to the first few indices of the variable's element table
              while the rest indices remain free. All elements with the
              remaining indices running from 1 to the appropriate
              dimension specify the element sub-table. If no indices are
              specified, the appropriate sub-table refers to the whole
              element table of a given variable. When as many indices
              are specified as the number of variable dimensions, the
              appropriate sub-table contains only one element. Examples:
            </p>
            <p><i>v [4 2]</i> </p>
            <p><i>v[3]</i> </p>
            <p><i>m [ ]</i> </p>
            <p><i>m</i> </p>
            <p><i>m[2, 4]</i> </p>
            <p><i>m [$a ${2*a}]</i> <br>
              &nbsp; <br>
              &nbsp; </p>
            <p><a name="_Toc442156988"></a> </p>
            <li> <b><font size="+1">Objects of Various Types</font></b></li>
            <p><br>
              When arguments are data objects of different types, there
              are basically two ways how to specify them in function's
              argument blocks. Either we specify values of the data
              object directly or refer to existing data elements of the
              user-defined variables of the appropriate type. </p>
            <p>When we <u>refer to an existent data element of a
                user-defined variable</u>, this is done <u>by the <i>$</i>
                sign followed by the element specification</u> (see the
              previous chapter!). Example: </p>
            <p><i>$m2[2 4]</i> </p>
            <p><i>$ m0</i> </p>
            <p>In this case a copy of the specified variable element is
              made and this copy is used by the function to which such
              specification was passed in the argument block. Spaces are
              allowed between the <i>$</i> sign and the element
              specification. The specification must be given as
              described in the previous chapter. </p>
            <p>When we <u>directly specify values of an object</u>,
              these must be <u>in curly brackets</u>, and the values
              must be specified <u>according to the rules that apply
                for a specific data type</u>. For the rules for various
              data types, refer to the descriptions of the functions for
              setting variable elements of that specific types. </p>
            <p>For example, we can specify the value of an matrix object
              this way: </p>
            <p><i>{ 2 2 {{1 1:1.1}{1 2:1.2}{2 1:2.1}{2 2:2.2}} }</i> </p>
            <p>The value specification must be put in curly brackets.
              This is to avoid the ambiguities that can arise because of
              two reasons. First, it is not always clear how long is
              such specification, i.e. where the next argument starts.
              For example, when we specify matrices, it is allowed to
              specify only dimensions without components. In the above
              example, only "<i>2 2</i>" could belong to a matrix
              specification and the rest of the line could be something
              else. Secondly, numerical arguments can be replaced by an
              expression evaluator's variable where a variable name
              follows the <i>$</i> sign. If the first number of the
              specification would be given this way, it could be
              understood that a matrix element of a user-defined matrix
              variable with rank zero was specified. For example, if we
              have difined an experession evaluator's variable <i>a</i>
              that has the value 2, the above line (without the outer
              brackets) could be replaced by the following one: </p>
            <p><i>$a 2 {{1 1:1.1}{1 2:1.2}{2 1:2.1}{2 2:2.2}}</i> </p>
            <p>When the matrix would be read, the function that does the
              job could think that <i>$a</i> refers to the element of a
              zero-rank matrix variable named <i>a</i>, but in fact
              this is only a replacement for number 2 and is a part of
              the matrix specification. The same rules as for matrices
              apply for data objects of other types. </p>
            <p>There are some <u>exceptions</u> at specifying data
              objects. Some functions don?t accept objects given by
              specifications of variable elements. Furtherly, some
              functions do not require that the value specification is
              in curly brackets. Both apply for the functions which set
              elements of user defined variables, such as <b>setmatrix</b>
              and <b>setvector</b>. <br>
              <a name="_Toc442156989"></a></p>
          </ol>
          <br>
          &nbsp;
          <li> <b><font size="+1">Functions for Input and Output</font></b></li>
          <br>
          &nbsp;
          <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
            <tbody>
              <tr nosave="" valign="TOP">
                <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
                <td nosave=""><b><font size="-1"><a
                        href="../manlist/index.html#list">Manuals list
                        &amp; contents</a></font></b></td>
                <td nosave=""><b><font size="-1"><a href="#contents">Table

                        of contents&nbsp;</a></font></b></td>
              </tr>
            </tbody>
          </table>
          <br>
          &nbsp; <br>
          &nbsp;
          <ol>
            <a name="_Toc442156990"></a>
            <li> <b><font size="+1">write</font><i> { arg1 arg2 ... }</i></b></li>
            <br>
            Prints the values of its arguments <i>arg1</i>, <i>arg2</i>,
            etc., to the standard output of the programme. Arguments can
            be strings, expression evaluator's variables, mathematical
            expressions, or special character sequences. Arguments must
            be separated by blank characters (i.e. spaces, newlines, or
            tabulators).
            <ol>
              &nbsp;
            </ol>
            Strings must be in double quotes. They can contain special
            character sequences, i.e. two character sequences that begin
            with the backslash character (\). These sequences are
            replaced by the appropriate special characters before the
            string is printed. An example of string argument is
            <p><i><font size="+0">"This is a\nstring."</font></i> </p>
            <p>Expression evaluator's variables must be given by the <i>$</i>
              character followed by the variable name. Blank characters
              (spaces, newlines and tabs) are alllowed between the <i>$</i>
              character and the variable name. The current value of the
              expression evaluator's variable is printed. An example of
              an expression evaluator's variable as an argument of <b>write</b>
              is </p>
            <p><i><font size="+0">$ v1</font></i> </p>
            <p>Mathematical expressions must be in curly bracked that
              follow the <i>$</i> character. Blank characters are
              allowed between the <i>$</i> character and the curly
              bracket. Blank characters are also allowed in the brackets
              since these characters are ignored in the mathematical
              expressions. The current value of the expression is
              printed. </p>
            <p><i><font size="+0">$ { a+3+b }</font></i> </p>
            <p>Special character sequences consist of the backslash
              character and of the specification character that follows
              immediately the backslash. The appropriate special
              character is printed (see Table 1 for the meaning of
              sequences). An example of a special character sequence as
              an argument of <b>write</b> is </p>
            <p><i><font size="+0">\t</font></i> <br>
              &nbsp; </p>
            <p><b>Example:</b> </p>
            <p>Let us say that we have defined the expression
              evaluator's variables <i>a</i>=5 and <i>b</i>=2.5. Then
              the command </p>
            <p><b><font size="+0">write</font> { "The value of a is " $a
                "\nand the value of"</b> </p>
            <p><b>\n\t "2*a+b\n is " ${2*a+b} "." \n }</b> </p>
            <p>will generate output like this: </p>
            <p><i><font size="+0">The value of a is 5</font></i> </p>
            <p><i>and the value of</i> </p>
            <p><i><font size="+0">2*a+b</font></i> </p>
            <p><i>is 10.</i> </p>
            <p>The first argument is a string and is printed literally.
              The second argument is an expression evaluator's variable,
              therefore its current value is printed. The third argument
              is again a string. It is printed literally except that the
              sequence <i>\n</i> is replaced by the appropriate special
              character, i.e. the newline. Then we have two special
              character sequences, <i>\n</i> and <i>\t</i>. The
              appropriate special characters, i.e. the newline and the
              tabulator are printed because of them. The sixth argument
              is a string again and is printed literally except that the
              special character sequences are replaced by the
              appropriate characters. The seventh argument is a
              mathematical expression and its current value is printed,
              i.e. 10. Then we have a string with one character that is
              printed literally, and a special character sequence, which
              causes the newline character to be printed. <br>
              &nbsp; </p>
            <p><a name="_Toc442156991"></a> </p>
            <li> <b><font size="+1">fwrite</font><i> { arg1 arg2 ... }</i></b></li>
            <br>
            Does the same as the <b>write</b> function, except that it
            prints to the programme's output file. This file is
            represented by the pre/defined file variable <i>outfile</i>.
            <br>
            &nbsp;
            <p><a name="_Toc442156992"></a> </p>
            <li> <b><font size="+1">dwrite</font><i> { arg1 arg2 ... }</i></b></li>
            <br>
            Does the same as the <b>write</b> function, except that it
            prints both to the standard output and to the programme's
            output file. What is printed to the standard output is
            identical to what is printed to the programme-s output file.
            <br>
            &nbsp;
            <p><a name="_Toc442156993"></a> </p>
            <li> <b><font size="+1">read</font><i> { varname }</i></b></li>
            <br>
            Reads a numerical value from the standard input and assigns
            it to the expression evaluator's variable named <i>varname</i>.
            If the expressinon evaluator's variable does not yet exist,
            it is created. <br>
            &nbsp; <br>
            &nbsp;
          </ol>
        </ol>
        <a name="_Toc442156994"></a>
        <li> <b><i><font size="+2">Branches and Loops</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <p>Branching and looping commands execute portions of code if
          certain conditions are fulfilled. The expression evaluator
          evaluates conditions; therefore they must be given by strings
          which represent mathematical expressions that can be evaluated
          by the expression evaluator. Both conditions and portions of
          code must be given in the argument block of the appropriate
          commands. </p>
        <ol>
          &nbsp;
        </ol>
        Since the expression evaluator evaluates branching and looping
        conditions, they can include calls to expression's functions for
        accessing shell's variables. Through them these conditions can
        include virtually every information, which at a given moment
        exists in the shell, inoculating results of algorithms and
        operation which have been performed before the condition
        evaluation.
        <ol>
          &nbsp;
          <ol>
            &nbsp;
          </ol>
          <a name="_Toc442156995"></a>
          <li> <b><font size="+1">Branching, Looping and Other Flow
                Control Functions</font></b></li>
          <br>
          &nbsp;
          <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
            <tbody>
              <tr nosave="" valign="TOP">
                <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
                <td nosave=""><b><font size="-1"><a
                        href="../manlist/index.html#list">Manuals list
                        &amp; contents</a></font></b></td>
                <td nosave=""><b><font size="-1"><a href="#contents">Table

                        of contents&nbsp;</a></font></b></td>
              </tr>
            </tbody>
          </table>
          <br>
          &nbsp;
        </ol>
        <ol>
          <ol>
            <a name="_Toc442156996"></a>
            <li> <b><font size="+1">if </font><i>{ ( condition ) [
                  block1 ] &lt; &lt; else &gt; [ block2 ] &gt; }</i></b></li>
            <br>
            The <b>if</b> command executes the portion of code <i>block1</i>
            if the <i>condition</i> evaluates to a non-zero value,
            otherwise it executes <i>block2</i> if it is specified.
            <ol>
              &nbsp;
            </ol>
            <i>condition</i> is an expression which can be evaluated by
            the expression evaluator. It must be given in round
            brackets. <i>block1</i> and <i>block2</i> are portions of
            code which can be executed (interpreted) by the file
            interpreter. They must be given in square brackets. If <i>block2</i>
            is specified, the user can optionally insert the word <i>else</i>
            for clearness.
            <ol>
              &nbsp; <br>
              &nbsp;
            </ol>
            <a name="_Toc442156997"></a>
            <li> <b><font size="+1">while</font><i> { ( condition ) [
                  block ] }</i></b></li>
            <br>
            The while function repeats execution (interpretation) of the
            portion of code <i>block</i> as long as the <i>condition</i>
            evaluates to a non-zero value. If the condition is not
            fulfilled when the function is called, <i>block</i> is not
            executed at all. <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442156998"></a> </p>
            <li> <b><font size="+1">do</font><i> { [ block ] &lt; while
                  &gt; (condition) }</i></b></li>
            <br>
            The <b>do</b> commands executes the portion of code <i>block</i>
            until the <i>condition</i> evaluates to zero. <i>block</i>
            is interpreted at least once because the condition is
            examined after its execution. When the <i>condition</i>
            evaluates to zero, <i>block</i> stops being executed and
            the <b>while</b> function exits.
            <ol>
              &nbsp;
            </ol>
            Word <i>while</i> can be added optionally for clearness. <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442156999"></a> </p>
            <li> <b><font size="+1">interpret</font><i> { filename }</i></b></li>
            <br>
            Interprets the file named <i>filename</i>. The whole file
            is interpreted. After the file is interpreted, the
            interpretation continues after the end of the function's
            argument block. <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442157000"></a> </p>
            <li> <b><font size="+1">exit</font><i> { &lt; numlev &gt; }</i></b></li>
            <br>
            The <b>exit</b> command causes exiting <i>numlev</i>
            interpretation levels. Interpretation is then continued. If
            the number of levels to exit <i>numlev</i> is not
            specified, the interpretation is interrupted completely.
            <ol>
              &nbsp;
            </ol>
            At the beginning of interpretation of the command file the
            level of interpretation is 1. The level increases by one
            every time a new block of commands is interpreted. This
            happens for example when a portion of code in a loop or
            branch is executed, when a definition block of a
            user-defined function of interpreter or calculator is
            executed, when the <b>analysis</b> function's argument
            block is executed or when a new file is interpreted. At the
            end of interpretation of such block the interpretation level
            is again decreased. <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442157001"></a> </p>
            <li> <b><font size="+1">block</font><i> { blockcode }</i></b></li>
            <br>
            The <b>block</b> function simply interprets its argument
            block <i>blockcode</i>. The interpretation level is
            increased by one when the interpretation begins and is
            decreased to previous value when it stops. Sometimes it is
            useful to use the <b>block</b> command because anywhere
            within the basic level of <i>blockcode</i> the rest of it
            can be skipped simply by the command <b>exit</b>{1}. We
            must be careful if we use the <b>exit</b> command with the
            <b>if</b> command, for example. Then we must increase the
            number of levels to exit because the interpretation level of
            the body of the <b>if</b> command is one more than the
            level of the surrounding code. We must call <b>exit</b>{2}
            instead of <b>exit</b>{1} in such cases. <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442157002"></a> </p>
            <li> <b><font size="+1">goto</font><i> { labelname }</i></b></li>
            <br>
            The <b>goto</b> function causes a jump in the
            interpretation. The interpretation continues from the
            position of the label named <i>labelname</i>. The label
            position must be given in the code by the <b>label</b>
            command and is considered to be the first character after
            the closing bracket of the <b>label</b> command.
            <ol>
              &nbsp;
            </ol>
            The label must exist in the same code block as the referring
            <b>goto</b> command, i.e. the <b>goto</b> command can be
            used only for jumps within the same interpretation level.
            <ol>
              &nbsp;
            </ol>
            The <b>goto</b> function origins from the time when loops
            were not available in the shell and is considered a bit
            obsolete. <br>
            &nbsp;
            <p><a name="_Toc442157003"></a> </p>
            <li> <b><font size="+1">label</font><i> { labelname }</i></b></li>
            <br>
            Specifies the position of the label named <i>labelname</i>.
            The command <b>goto </b><i>{labelname}</i> causes
            continuation of the interpretation from the first character
            after the closing bracket of the <b>label</b> command-s
            argument block. <br>
            &nbsp;
            <p><a name="_Toc442157004"></a> </p>
            <li> <b><font size="+1">comment</font><i> { comments }</i>,
                *<i> { comments }</i></b></li>
            <br>
            Does nothing. This function is used for putting comments in
            the code. The comments are put to the argument block of the
            function. <br>
            &nbsp; <br>
            &nbsp;
          </ol>
        </ol>
        <a name="_Toc442157005"></a>
        <li> <b><i><font size="+2">Definition of New File Interpreter's
                Functions</font></i></b></li>
        <br>
        &nbsp;
        <table nosave="" cellpadding="3" border="3" bgcolor="#FFFFCC">
          <tbody>
            <tr nosave="" valign="TOP">
              <td><b><font size="-1"><a href="#list">Manuals list</a></font></b></td>
              <td nosave=""><b><font size="-1"><a
                      href="../manlist/index.html#list">Manuals list
                      &amp; contents</a></font></b></td>
              <td nosave=""><b><font size="-1"><a href="#contents">Table
                      of contents&nbsp;</a></font></b></td>
            </tr>
          </tbody>
        </table>
        <br>
        &nbsp;
        <ol>
          <ol>
            <a name="_Toc442157006"></a>
            <li> <b><font size="+1">function</font><i> { funcname (
                  arglist ) [ defblock ] }</i></b></li>
            <br>
            The <b>function</b> command defines a new file
            interpreter's function. The first argument <i>funcname</i>
            is the name of the newly defined function. A list of formal
            argument names <i>arglist</i> follows in round brackets.
            Finally, the function's definition block <i>defblock</i> is
            given in square bracket. This block is interpreted every
            time a newly defined function is called.
            <ol>
              &nbsp;
            </ol>
            The formal argument names must be separated by spaces or
            commas. They must be strings consisting of letters and
            numbers starting with a letter (the same applies to <i>funcname</i>).
            These names are used in the function's definition block. <u>Formal
              arguments are referenced in the <i>defblock</i> by the <i>$</i>
              sign immediately followed by argument's name. References
              to arguments are replaced by actual arguments when the
              function is called.</u>
            <ol>
              &nbsp;
            </ol>
            A function defined by the <b>function</b> command can be
            used as any other function. Its call consists of function
            name (<i>funcname</i>) followed by an argument block in
            curly brackets. When the file interpreter hits a call to
            such function, all references to function's arguments in the
            function's definition block <i>defblock</i> are replaces
            with actual arguments on the string basis, and then <i>defblock</i>
            is interpreted. In the function call arguments must be
            separated with spaces or commas. If the string which
            represent an argument contains spaces, it must be enclosed
            in curly brackets, otherwise it is not considered as one
            argument.
            <ol>
              &nbsp;
            </ol>
            It is important to know that strings which represent actual
            arguments at a function call are pasted in the place of
            references to formal arguments in the <i>defblock</i> as
            strings. This means that there is no general way to check
            the appropriateness of arguments passed to the function. It
            is completely on the function's definition how to treat
            function's arguments, including possible checking of
            appropriateness. The good thing of such approach is that
            practically everything can be an argument of a user-defined
            function, including variables, mathematical expressions,
            strings, portions of interpretable code, etc.
            <ol>
              &nbsp;
            </ol>
            <b>Referencing arguments by their sequential numbers:</b>
            <ol>
              &nbsp;
            </ol>
            There exists another mechanisms of argument passing for
            user-defined function, which looks a bit exotic at first
            sight and can be avoided in most cases, but on the other
            hand introduces a lot of additional freedom and
            functionality into the shell's programming.
            <ol>
              &nbsp;
            </ol>
            Besides referencing arguments in the <i>defblock</i> by
            their names specified in the <i>arglist</i> proceeded by
            the <i>$</i> sign, the user can also <u>reference
              function's arguments by their sequential numbers</u> at
            the function call. The sequential numbers of actual
            arguments passed to a function must appear <u>in curly
              brackets which follow the <i>#</i> sign</u>, and <u>can
              be given by mathematical expressions</u> which can be
            evaluated in the expression evaluator. Portions of code,
            which include such references to function arguments, must be
            <u>included in the argument block of the <b>update</b>
              command</u>. The <b>update</b> command evaluates the
            expressions, which represent the arguments? sequential
            numbers within its argument block, replaces the references
            to arguments by actual arguments, and interprets its
            argument block. Argument references are simply replaced with
            strings which represent the appropriate arguments at the
            function call, the same as is the case with arguments
            specified in the <i>arglist</i>.
            <ol>
              &nbsp;
            </ol>
            The expression evaluator's function <b>numfuncargs</b> can
            be used while referencing function's arguments in the <i>defblock</i>
            by their sequential numbers. When called within a definition
            block of a user-defined function, the <b>numfuncargs</b>
            function returns the number of arguments, which are actually
            passed, to the function at its call.
            <ol>
              &nbsp;
            </ol>
            An important feature of referencing arguments by sequential
            numbers is that the <u>replacements of arguments referenced
              by sequential numbers is</u> not <u>performed</u> at
            function call as is the case by arguments referenced by
            names in the <i>arglist</i>, but <u>at the call to the
              appropriate <b>update</b> command</u> which includes the
            corresponding argument references in its argument block. If
            we have loops in the <i>defblock</i>, it can therefore make
            a difference if we include a whole loop or just a body of
            the loop in the <b>update</b> command's argument block,
            since the values of expressions which determine the
            argument's sequential number can vary at consequent passes
            of the loop's body. The effect of replacing argument
            references by actual arguments at the call to the <b>update</b>
            function is clearly shown in one of the examples below.
            <ol>
              &nbsp;
            </ol>
            <u>Nested calls to the <b>update</b> function do not make
              sense</u> since argument replacement is performed at the
            outer-most <b>update</b> command. All calls to the <b>update</b>
            functions, which appear in the argument block of another
            update command, are therefore redundant.
            <ol>
              &nbsp;
            </ol>
            It is important to remember that every reference to
            function's argument by its sequential number <b><i>must</i></b>
            be included in an argument block of the <b>update</b>
            command, otherwise it is not replaced by the corresponding
            argument of the appropriate user defined function's call.
            <ol>
              &nbsp;
            </ol>
            The two mechanisms of argument referencing can be mixed.
            Argument names listed in the <i>arglist</i> always refer to
            the first <i>N</i> arguments in the appropriate order,
            where <i>N</i> is the number of arguments specified in the
            <i>arglist</i>. If an argument is listed in the <i>arglist</i>,
            this does not prevent referencing it by its sequential
            number rather by its formal name.
            <ol>
              &nbsp;
            </ol>
            <b>Examples:</b>
            <ol>
              &nbsp;
            </ol>
            The first example shows how to define a function <i>increment</i>
            which increments an expression evaluator's variable by 1:
            <ol>
              &nbsp;
            </ol>
            <b><font size="+0">function</font> { increment ( var ) [ =
              {$var:$var+1} ] }</b>
            <ol>
              &nbsp;
            </ol>
            The function takes one argument, which is the name of the
            calculator's, variable. When it is called, it increments the
            calculator's variable with such name. Code where the
            functions is used can look like this:
            <ol>
              &nbsp;
            </ol>
            <font size="+0"><b>=</b> {x:1}</font>
            <ol>
              &nbsp;
            </ol>
            <font size="+0"><b><i>inc</i></b> {x}</font>
            <ol>
              &nbsp;
            </ol>
            <font size="+0"><b>print</b> { "x = " $ x "\n." }</font>
            <ol>
              &nbsp;
            </ol>
            This portion of code defines a new calculator's variable
            named <i>x</i> and assigns it the value 1, increments this
            variable by 1 using the user-defined function <i>increment</i>,
            and prints its value to the standard output.
            <ol>
              &nbsp;
            </ol>
            The next example shows how the user can define the <i>for</i>
            loop which is not defined in the shell:
            <p><b><font size="+0">function</font> { for ( begin
                condition end body )</b> </p>
            <p><b>[</b> </p>
            <p><b><i>$begin</i></b> </p>
            <p><b>while { ( <i>$condition</i> )</b> </p>
            <p><b>[</b> </p>
            <p><b><i>$body</i></b> </p>
            <p><b><i>$end</i></b> </p>
            <p><b>] }</b> </p>
            <p><b>] }</b> </p>
            <p>This function takes four arguments: the <i>begin</i>
              block which is interpreted at the beginning and is
              typically an initialisation of the loop counter, the
              condition for the <b>while</b> loop, the <i>end</i>
              block which is interpreted at the end of the <b>while</b>
              block and typically includes incrementation of the
              counter, and the <i>body</i> block which represents the
              body of the <i>for</i> loop and is interpreted at the
              beginning of the <b>while</b> loop. </p>
            <p>For example, here is a portion of code, which uses the
              newly defined <i>for</i> loop and writes numbers from 1
              to 100 to the standard output: </p>
            <p><b><i><font size="+0">for</font></i> { ={icount:1}
                i&lt;=100 ={i&gt;i+1} { write { $i } write { "\n" } } }</b>
            </p>
            <p>When the <i>for</i> function is called in the above
              code, its arguments in the argument block replace formal
              arguments in the definition block of the function, which
              gives the following code: </p>
            <p><font size="+0"><b>=</b>{icount:1}</font> </p>
            <p><font size="+0"><b>while</b> { ( icount&lt;=100 )</font>
            </p>
            <p><font size="+0">[</font> </p>
            <p><font size="+0"><b>write</b> { $icount } <b>write</b> {
                "\n" }</font> </p>
            <p><font size="+0"><b>=</b>{icount:icount+1}</font> </p>
            <p><font size="+0">] }</font> </p>
            <p>This code is then executed which writes numbers from 1 to
              100 to the standard output. The last argument was a block
              of two function calls and contained spaces, therefore it
              was enclosed in curly brackets. </p>
            <p>The next example illustrates referencing the user-defined
              function's arguments by sequential numbers, which is mixed
              with standard approach, i.e. referencing by names listed
              in the <i>arglist</i>. The example shows how to define a
              new expression evaluator's function <i>evaluatefunctions</i>
              which evaluates an arbitrary number of expression
              evaluator's functions of one variable at a specific value
              of the independent variable and outputs the results to the
              standard output and programme's output file: </p>
            <p><b><font size="+0">function</font> {evaluatefunctions (x)</b>
            </p>
            <p><b>[</b> </p>
            <p><b>={icount:2}</b> </p>
            <p><b>while { (icount&lt;=numfuncargs[])</b> </p>
            <p><b>[</b> </p>
            <p><b>update</b> </p>
            <p><b>{</b> </p>
            <p><b>write { "#{icount}[" ${$x} "] = " ${ #{icount}[$x] }
                \n }</b> </p>
            <p><b>fwrite { "#{icount}[" ${$x} "] = " ${ #{icount}[$x] }
                \n }</b> </p>
            <p><b>}</b> </p>
            <p><b>={icount:icount+1}</b> </p>
            <p><b>] }</b> </p>
            <p><b>write {\n}</b> </p>
            <p><b>fwrite {\n}</b> </p>
            <p><b>] }</b> </p>
            <p>The code </p>
            <p><b><i><font size="+0">evalfunctions</font></i> {0.0 sin
                cos exp}</b> </p>
            <p>will generate the following output: </p>
            <p><font size="-1">sin[0] = 0</font> </p>
            <p><font size="-1">cos[0] = 1</font> </p>
            <p><font size="-1">exp[0] = 1</font> </p>
            <p>When the function is called, all references to arguments
              by name are immediately replaced by the strings
              representing function's actual arguments in the function's
              definition block. In the above case all strings "<i>$x</i>"
              are replaced by the string "<i>0.0</i>", which gives the
              following code of the function's definition block: </p>
            <p><font size="+0"><b>=</b>{icount:2}</font> </p>
            <p><font size="+0"><b>while</b> { (icount&lt;=numfuncargs[])</font>
            </p>
            <p><font size="+0">[</font> </p>
            <p><b><font size="+0">update</font></b> </p>
            <p><font size="+0">{</font> </p>
            <p><font size="+0"><b>write</b> { "#{icount}[" ${0.0} "] = "
                ${ #{icount}[0.0] } \n }</font> </p>
            <p><font size="+0"><b>fwrite</b> { "#{icount}[" ${0.0} "] =
                " ${ #{icount}[0.0] } \n }</font> </p>
            <p><font size="+0">}</font> </p>
            <p><font size="+0"><b>=</b>{icount:icount+1}</font> </p>
            <p><font size="+0">] }</font> </p>
            <p><font size="+0"><b>write</b> {\n}</font> </p>
            <p><font size="+0"><b>fwrite</b> {\n}</font> </p>
            <p>The replacement of the argument references by sequential
              numbers is accomplished each time the <b>update</b>
              command which contains the appropriate references is
              executed. This happens in each execution of the <b>while</b>
              loop's body. This is executed for <i>icount</i>=2, <i>icount</i>=3

              and <i>icount</i>=4, since the number of arguments passed
              at the function call is 4 and this is returned by the <b>numfuncargs</b>
              function of the expression evaluator. At the first
              execution of the <b>while </b>loop's body the value of <i>icount</i>
              is 2, therefore strings <i>#{icount}</i> in the argument
              block of the <b>update</b> command are replaced by the
              string "<i>sin</i>" and the code which is actually
              executed looks like this: </p>
            <p><font size="+0"><b>write</b> { "sin[" ${0.0} "] = " ${
                sin[0.0] } \n }</font> </p>
            <p><font size="+0"><b>fwrite</b> { "sin[" ${0.0} "] = " ${
                sin[0.0] } \n }</font> </p>
            <p><font size="+0"><b>=</b>{icount:icount+1}</font> </p>
            <p>In the next pass of the <b>while</b> loop the value of <i>icount</i>
              is 3, therefore strings <i>#{icount}</i> are replaced by
              the string "<i>cos</i>" which represents the third
              argument passed at the function call. The appropriate code
              that is executed at the second pass of the while loop
              therefore looks like this: </p>
            <p><font size="+0"><b>write</b> { "cos[" ${0.0} "] = " ${
                cos[0.0] } \n }</font> </p>
            <p><font size="+0"><b>fwrite</b> { "cos[" ${0.0} "] = " ${
                cos[0.0] } \n }</font> </p>
            <p><font size="+0"><b>=</b>{icount:icount+1}</font> <br>
              &nbsp; <br>
              &nbsp; </p>
            <p><b>Warning:</b> </p>
            <p>At the definition of new functions we must be careful
              with the use of variables. The interpreter does not know
              local variables, therefore all variable names are global.
              Auxiliary variables in the function definitions (counters,
              variables for storing intermediate results, etc.) must
              therefore have different names as variables used for other
              purposes outside the function definition. Interference can
              usually be avoided by using long, strange or meaningless
              names for auxiliary variables used in the function's
              definition block. </p>
            <ol>
              &nbsp; <br>
              &nbsp;
            </ol>
            <a name="_Toc442157007"></a>
            <li> <b><font size="+1">update</font><i> { code }</i></b></li>
            <br>
            The file interpreter-s function <b>update</b> can be used
            only within a definition block of a user-defined
            interpreter's function. This function first replaces all
            references to user-defined function arguments by sequential
            numbers with the strings representing the appropriate actual
            arguments, and then interprets its argument block (see the
            reference for the <b>function</b> command). <br>
            &nbsp; <br>
            &nbsp;
            <p><a name="_Toc442157008"></a> </p>
            <li> <b><font size="+1">numfuncargs</font><i> [ ]</i></b></li>
            <br>
            The expression evaluator's function <b>numfuncargs</b>
            returns the number of arguments passed to a user-defined
            function in the definition block of which the <b>numfuncargs</b>
            function is evaluated. See the reference for the <b>function</b>
            command for more details! <br>
            &nbsp; <br>
            &nbsp; <br>
            &nbsp;
            <ol>
              &nbsp;
            </ol>
          </ol>
        </ol>
      </ol>
    </ol>
  </body>
</html>
